# 이펙티브 타입스크립트

## 목차

- [타입스크립트와 자바스크립트의 관계 이해하기](#타입스크립트와-자바스크립트의-관계-이해하기)
- [타입스크립트 설정 이해하기](#타입스크립트-설정-이해하기)
- [코드 생성과 타입이 관계없음을 이해하기](#코드-생성과-타입이-관계없음을-이해하기)
- [구조적 타이핑에 익숙해지기](#구조적-타이핑에-익숙해지기)
- [any 타입 지양하기](#any-타입-지양하기)
- [편집기를 사용하여 타입 시스템 탐색하기](#편집기를-사용하여-타입-시스템-탐색하기)
- [타입이 값들의 집합이라고 생각하기](#타입이-값들의-집합이라고-생각하기)
- [타입 공간과 값 공간의 심벌 구분하기](#타입-공간과-값-공간의-심벌-구분하기)
- [타입 단언보다는 타입 선언을 사용하기](#타입-단언보다는-타입-선언을-사용하기)
- [잉여 속성 체크의 한계 인지하기](#잉여-속성-체크의-한계-인지하기)
- [함수 표현식에 타입 적용하기](#함수-표현식에-타입-적용하기)
- [타입과 인터페이스의 차이점 알기](#타입과-인터페이스의-차이점-알기)
- [타입 연산과 제너릭 사용으로 반복 줄이기](#타입-연산과-제너릭-사용으로-반복-줄이기)
- [동적 데이터에 인덱스 시그니처 사용하기](#동적-데이터에-인덱스-시그니처-사용하기)
- [number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기](#number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기)
- [변경 관련된 오류 방지를 위해 readonly 사용하기](#변경-관련된-오류-방지를-위해-readonly-사용하기)
- [매핑된 타입을 사용하여 값을 동기화하기](#매핑된-타입을-사용하여-값을-동기화하기)
- [추론 가능한 타입을 사용해 장황한 코드 방지하기](#추론-가능한-타입을-사용해-장황한-코드-방지하기)
- [다른 타입에는 다른 변수 사용하기](#다른-타입에는-다른-변수-사용하기)
- [타입 넓히기](#타입-넓히기)
- [타입 좁히기](#타입-좁히기)
- [한꺼번에 객체 생성하기](#한꺼번에-객체-생성하기)
- [일관성 있는 별칭 사용하기](#일관성-있는-별칭-사용하기)
- [비동기 코드에는 콜백 대신 async 함수 사용하기](#비동기-코드에는-콜백-대신-async-함수-사용하기)
- [타입 추론에 문맥이 어떻게 사용되는지 이해하기](#타입-추론에-문맥이-어떻게-사용되는지-이해하기)
- [유효한 상태만 표현하는 타입을 지향하기](#유효한-상태만-표현하는-타입을-지향하기)
- [사용할 때는 너그럽게, 생성할 때는 엄격하게](#사용할-때는-너그럽게-생성할-때는-엄격하게)
- [문서에 타입 정보를 쓰지 않기](#문서에-타입-정보를-쓰지-않기)
- [타입 주변에 null 값 배치하기](#타입-주변에-null-값-배치하기)
- [유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기](#유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기)
- [string 타입보다 더 구체적인 타입 사용하기](#string-타입보다-더-구체적인-타입-사용하기)
- [부정확한 타입보다는 미완성 타입을 사용하기](#부정확한-타입보다는-미완성-타입을-사용하기)
- [해당 분야의 용어로 타입 이름 짓기](#해당-분야의-용어로-타입-이름-짓기)
- [공식 명칭에는 상표를 붙이기](#공식-명칭에는-상표를-붙이기)
- [any 타입은 가능한 한 좁은 범위에서만 사용하기](#any-타입은-가능한-한-좁은-범위에서만-사용하기)
- [any를 구체적으로 변형해서 사용하기](#any를-구체적으로-변형해서-사용하기)
- [함수 안으로 타입 단언문 감추기](#함수-안으로-타입-단언문-감추기)
- [any의 진화를 이해하기](#any의-진화를-이해하기)
- [모르는 타입의 값에는 any 대신 unknown을 사용하기](#모르는-타입의-값에는-any-대신-unknown을-사용하기)
- [몽키 패치보다는 안전한 타입을 사용하기](#몽키-패치보다는-안전한-타입을-사용하기)
- [타입 커버리지를 추적하여 타입 안전성 유지하기](#타입-커버리지를-추적하여-타입-안전성-유지하기)
- [devDependencies에 typescript와 @types추가하기](#devdependencies에-typescript와-types추가하기)
- [타입 선언과 관련된 세 가지 버전 이해하기](#타입-선언과-관련된-세-가지-버전-이해하기)
- [공개 API에 등장하는 모든 타입을 익스포트하기](#공개-api에-등장하는-모든-타입을-익스포트하기)
- [API 주석에 TSDoc 사용하기](#api-주석에-tsdoc-사용하기)
- [콜백에서 this에 대한 타입 제공하기](#콜백에서-this에-대한-타입-제공하기)
- [오버로딩 타입보다는 조건부 타입을 사용하기](#오버로딩-타입보다는-조건부-타입을-사용하기)
- [의존성 분리를 위해 미러 타입 사용하기](#의존성-분리를-위해-미러-타입-사용하기)
- [타입스크립트 기능보다는 ECMAScript 기능을 사용하기](#타입스크립트-기능보다는-ecmascript-기능을-사용하기)
- [객체를 순회하는 노하우](#객체를-순회하는-노하우)
- [DOM 계층 구조 이해하기](#dom-계층-구조-이해하기)
- [정보를 감추는 목적으로 private 사용하지 않기](#정보를-감추는-목적으로-private-사용하지-않기)
- [소스맵을 사용하여 타입스크립트 디버깅하기](#소스맵을-사용하여-타입스크립트-디버깅하기)
- [모던 자바스크립트로 작성하기](#모던-자바스크립트로-작성하기)
- [타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기](#타입스크립트-도입-전에-ts-check와-jsdoc으로-시험해-보기)
- [의존성 관계에 따라 모듈 단위로 전환하기](#의존성-관계에-따라-모듈-단위로-전환하기)
- [마이그레이션의 완성을 위해 noImplicitAny 설정하기](#마이그레이션의-완성을-위해-noimplicitany-설정하기)

## 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 자바스크립트의 상위집합이다.  
자바스크립트 프로그램에 문법 오류가 없다면, 유효한 타입스크립트 프로그램이라고 할 수 있다.  
모든 자바스크립트 프로그램이 타입스크립트라는 명제는 참이지만, 그 반대는 성립하지 않는다.  
자바스크립트의 런타임 동작을 모델링하는 것은 타입스크립트 타입 시스템의 기본 원칙이다.  
타입 시스템이 정적 타입의 정확성을 보장하지 않는다.

## 타입스크립트 설정 이해하기

tsconfig.json 설정 파일을 사용하는 것이 좋다.  
설정을 제대로 사용하려면, noImplicitAny와 strictNullChecks를 이해해야 한다.  
noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.  
strictNullChecks는 null과 undefined가 모든 타입에서 혀용되는지 확인하는 설정이다.  
프로젝트가 거대해질수록 설정 변경은 어려워질 것이므로, 가능한 한 초반에 설정하는 게 좋다.  
타입스크립트에 strict 설정을 하면 대부분의 오류를 잡아낸다.

## 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러의 트랜스파일과 타입 체크는 독립적으로 수행된다.  
타입 오류가 있는 코드도 컴파일이 가능하다.  
런타임에는 타입 체크가 불가능하다.  
런타임에 타입 정보를 손쉽게 유지하기 위해 태그된 유니온 기법을 사용한다.  
타입과 값을 둘 다 사용하는 방법으로는 타입을 클래스로 만드는 것이다.  
타입 연산은 런타임에 영향을 주지 않는다.  
런타임 타입은 선언된 타입과 다를 수 있다.  
타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

## 구조적 타이핑에 익숙해지기

자바스크립트는 덕 타이핑 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야 한다.  
함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하기 쉽다.  
타입은 좋든 싫든 열려있다.  
구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.

## any 타입 지양하기

any 타입에는 타입 안전성이 없다.  
any는 함수 시그니처를 무시해 버린다.  
any 타입에는 언어 서비스가 적용되지 않는다.  
any 타입은 코드 리팩터링 때 버그를 감춘다.  
any는 타입 설계를 감춰버린다.  
any는 타입시스템의 신뢰도를 떨어뜨린다.

## 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 컴파일러와 서버를 실행할 수 있다.  
서버에서 언어 서비스를 제공한다. 언어 서비스는 코드 자동 완성, 명세 검사, 검색, 리팩터링이 포함된다.  
보통은 편집기를 통해서 언어 서비스를 사용하는데, 서버에서 언어 서비스를 제공하도록 설정하는 게 좋다.  
편집기는 코드를 빌드하고 타입 시스템을 익힐 수 있는 최고의 수단이다.  
편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.  
추론 정보는 디버깅하는 데 꼭 필요하다.  
타입 선언은 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링되었는지, 어떻게 오류를 찾아낼지 살펴볼 수 있는 훌륭한 수단이다.

## 타입이 값들의 집합이라고 생각하기

타입을 값의 집합으로 생각하면 이해하기 편하다.  
타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 벤 다이어그램으로 표현된다.  
타입 연산은 집합의 범위에 적용된다.  
객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.  
'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분 집합'과 같은 의미다.

## 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.  
모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.  
연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 타입 단언보다는 타입 선언을 사용하기

타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.  
타입 선언문에서는 잉여 속성 체크가 동작했지만, 단언문에서는 적용되지 않는다.  
타입 단언은 타입 체커가 추론한 타입보다 여러분이 판단하는 타입이 더 정확할 때 의미가 있다.  
타입 단언문으로 임의의 타입 간에 변환을 할 수는 없고 부분 집합인 경우에 타입 단언문을 사용해 변환할 수 있다.

## 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 그 외의 속성은 없는지 확인한다.  
잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않을 수 있다.  
잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.  
약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다.  
잉여 속성 체크는 구조적 타이핑 시스템에서 혀용되는 속성 이름의 오타 같은 실수를 잡는 데 효과적인 방법이다.

## 함수 표현식에 타입 적용하기

타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.  
다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나, 동일한 타입 시그니처를 가지는 여러 개의 함수를 작성할 때는 함수 전체의 타입 선언을 적용해야 한다.  
다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

## 타입과 인터페이스의 차이점 알기

타입과 인터페이스 사이에 존재하는 차이를 분명하게 알고, 같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야 한다.  
인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지는 못한다.  
type 키워드는 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에 활용되기도 한다.  
인터페이스로 튜플과 비슷하게 구현하면 concat 같은 메서드들을 사용할 수 없으므로 튜플은 type 키워드로 구현하는 것이 낫다.  
인터페이스는 선언 병합이 가능하다. 선언 병합은 주로 타입 선언 파일에서 사용된다.
프로젝트에서 어떤 문법을 사용할지 결정할 때 한 가지 일관된 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다.

## 타입 연산과 제너릭 사용으로 반복 줄이기

타입 중복은 코드 중복만큼 많은 문제를 발생시킨다.  
타입에 이름을 붙이거나 extends를 사용해서 인터페이스 필드의 반복을 피해야 한다.  
타입들 간의 매핑을 위해 타입스크립트가 제공한 도구들을 알면 좋다.  
타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋다.

## 동적 데이터에 인덱스 시그니처 사용하기

타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.  
인덱스 시그니처를 사용하면 잘못된 키를 포함해 모든 키를 허용하고 특정 키가 필요하지 않으며 키마다 다른 타입을 가질 수 없다. 또한 키는 무엇이든 가능하기 때문에 자동 완성 기능이 동작하지 않는다.  
런타임 때까지 객체의 속성을 알 수 없는 경우에만 인덱스 시그니처를 사용하도록 한다.  
안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 한다.  
인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

## number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

배열은 객체이므로 키는 숫자가 아니라 문자열이다.  
인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다.  
인덱스 시그니처에 number를 사용하기보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.

## 변경 관련된 오류 방지를 위해 readonly 사용하기

매개변수를 readonly로 선언하면 다음과 같은 일이 생긴다.

- 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크한다.
- 호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받게 된다.
- 호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수도 있다.

자바스크립트, 타입스크립트에서는 암묵적으로 함수가 매개변수를 변경하지 않는다고 가정한다. 그러나 이러한 암묵적인 방법은 타입 체크에 문제를 일으킬 수 있다.  
만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋다.  
readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있다.  
readonly는 얕게 동작한다는 것을 명심해야 한다.

## 매핑된 타입을 사용하여 값을 동기화하기

매핑된 타입을 사용해서 관련된 값과 타입을 동기화하도록 한다.  
인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 한다.

## 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입 추론이 된다면 명시적 타입 구문은 필요하지 않고 오히려 방해가 될뿐이다.  
타입스크립트에서 변수의 타입은 일반적으로 처음 등장할 때 결정된다.  
이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다.  
타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.  
보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론된다.  
추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다.

## 다른 타입에는 다른 변수 사용하기

변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다.  
타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것이다.  
혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 한다.  
다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유는 다음과 같다.

- 서로 관련이 없는 두 개의 값을 분리한다.
- 변수명을 더 구체적으로 지을 수 있다.
- 타입 추론을 향상시키며, 타입 구문이 불필요해진다.
- 타입이 좀 더 간결해진다.
- let 대신 const로 변수를 선언하게 된다. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋다.

## 타입 넓히기

타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 가능한 값들의 집합인 타입을 가진다.  
지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추하는 과정을 넓히기라고 부른다.  
넓히기 과정을 제어할 수 있는 방법으로 const, 타입 구문, 타입 체커에 추가적인 문맥을 제공, as const가 있다.

## 타입 좁히기

타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.  
타입 체커는 일반적으로 조건문에서 타입 좁히기를 잘 해내지만, 타입 별칭이 존재한다면 그러지 못할 수도 있다.  
분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.  
instanceof, 속성 체크, Array.isArray로 타입을 좁힐 수 있다.  
태그된/구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원활하게 만들 수 있다.

## 한꺼번에 객체 생성하기

객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.  
객체를 반드시 제각각 나눠서 만들어야 한다면, 타입 단언문을 사용해 타입 체커를 통과하게 할 수 있다.  
작은 객체들을 조합해서 큰 객체를 만들어야 하는 경우에는 객체 전개 연산자를 사용하면 된다.  
타입에 안전한 방식으로 조건부 속성을 추가하려면, 속성을 추가하지 않는 null 또는 {}으로 객체 전개를 사용하면 된다.  
조건부 속성으로 하나의 속성을 추가하면 선택적 속성을 가진 것으로 추론되고 여러 속성을 추가하면 유니온으로 추론된다.

## 일관성 있는 별칭 사용하기

별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.  
비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.  
함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.

## 비동기 코드에는 콜백 대신 async 함수 사용하기

콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.  
가능하면 프로미스를 생성하기보다는 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있다.  
어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.

## 타입 추론에 문맥이 어떻게 사용되는지 이해하기

타입스크립트는 타입을 추론할 때 단순히 값만 고려하지는 않고 값이 존재하는 곳의 문맥까지 살핀다.  
변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 한다.  
변수가 정말로 상수라면 상수 단언을 사용해야 한다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생하므로 주의해야 한다.

## 유효한 상태만 표현하는 타입을 지향하기

유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.  
유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.

## 사용할 때는 너그럽게, 생성할 때는 엄격하게

함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.  
선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.  
매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하는 것이 좋다.

## 문서에 타입 정보를 쓰지 않기

주석과 변수명에 타입 정보를 적는 것은 피해야 한다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 된다.  
타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.

## 타입 주변에 null 값 배치하기

한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안 된다.  
API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 한다.  
클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다.

## 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기

유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의해야 한다.  
유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기도 좋다.  
타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 한다.

## string 타입보다 더 구체적인 타입 사용하기

모든 문자열을 할당할 수 있는 string 타입보다는 더 구체적인 타입을 사용하는 것이 좋다.  
변수의 범위를 보다 정확하게 표현하고 싶다면 string 타입보다는 문자열 리터럴 타입의 유니온을 사용하면 된다.  
객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T를 사용하는 것이 좋다.

## 부정확한 타입보다는 미완성 타입을 사용하기

타입 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 타입이 없는 것보다 못할 수 있다.  
타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다.  
타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제는 더 커질 것이다.

## 해당 분야의 용어로 타입 이름 짓기

엄선된 타입, 속성, 변수의 이름은 의도를 명확히 하고 코드와 타입의 추상화 수준을 높여 준다.  
잘못 선택한 타입 이름은 코드의 의도를 왜곡하고 잘못된 개념을 심어 주게 된다.  
자체적으로 용어를 만들어 내려고 하지 말고, 해당 분야에 이미 존재하는 용어를 사용해야 한다.  
동일한 의미를 나타낼 때는 같은 용어를 사용해야 한다.  
모호하고 의미 없는 이름은 피해야 한다.  
이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려해야 한다.

## 공식 명칭에는 상표를 붙이기

타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 세밀하게 구분하지 못하는 경우가 있다. 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려해야 한다.  
상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다.  
타입 시스템이기 때문에 런타임 오버헤드를 없앨 수 있고 추가 속성을 붙일 수 없는 string이나 number 같은 내장 타입도 상표화할 수 있다.

## any 타입은 가능한 한 좁은 범위에서만 사용하기

의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.  
함수의 반환 타입이 any인 경우 타입 안정성이 나빠지므로 any 타입을 반환하면 절대 안 된다.  
강제로 타입 오류를 제거하려면 any 대신 @ts-ignore을 사용하는 것이 좋다.

## any를 구체적으로 변형해서 사용하기

일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재할 가능성이 높기 때문에 더 구체적인 타입을 찾아 타입 안전성을 높이도록 해야 한다.  
any보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[id: string]: any}` 또는 `() => any`처럼 구체적인 형태를 사용해야 한다.  
`{[id: string]: any}` 대신 모든 비기본형 타입을 포함하는 object 타입을 사용할 수도 있다. object 타입은 객체의 키를 열거할 수는 있지만 속성에 접근할 수 없다.

## 함수 안으로 타입 단언문 감추기

함수를 작성하다 보면, 외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많다.  
함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는 게 낫다.  
프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다, 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계다.

## any의 진화를 이해하기

any 타입의 진화는 noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 일어난다.  
어떤 변수가 암시적 any 상태일 때 값을 읽으려고 하면 오류가 발생한다.  
any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.

## 모르는 타입의 값에는 any 대신 unknown을 사용하기

어떠한 타입이든 unknown에 할당 가능하지만 unknown은 오직 unknown과 any에만 할당 가능하다.  
제네릭보다는 unknown을 반환하고 사용자가 직접 단언문을 사용하거나 원하는 대로 타입을 좁히도록 강제하는 것이 좋다.  
unknown에 대해서 설명한 것과 비슷한 방식으로 object 또는 {}가 존재한다. {} 타입은 null과 undefined를 제외한 모든 값을 포함하고 object 타입은 모든 비기본형 타입으로 이루어진다.

## 몽키 패치보다는 안전한 타입을 사용하기

전역 변수나 DOM에 데이터를 저장하지 말고, 데이터를 분리하여 사용해야 한다.  
내장 타입에 데이터를 저장해야 하는 경우, 보강이나 사용자 정의 인터페이스로 단언을 사용해야 한다.  
보강은 전역적으로 적용되기 때문에, 코드의 다른 부분이나 라이브러리로부터 분리할 수 없다. 그리고 애플리케이션이 실행되는 동안 속성을 할당하면 실행 시점에서 보강을 적용할 방법이 없다.

## 타입 커버리지를 추적하여 타입 안전성 유지하기

noImplicitAny가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언(@types)을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 한다.  
작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 한다. 추적함으로써 any의 사용을 줄여 나갈 수 있고 타입 안전성을 꾸준히 높일 수 있다.

## devDependencies에 typescript와 @types추가하기

npm은 세 가지 종류의 의존성을 구분해서 관리한다.

- dependencies  
  현재 프로젝트를 실행하는 데 필수적인 라이브러리들이 포함된다.
- devDependencies  
  현재 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리들이 포함된다.
- peerDependencies  
   런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리들이 포함된다.

타입스크립트를 시스템 레벨로 설치하면 안된다.  
@types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야 한다.

## 타입 선언과 관련된 세 가지 버전 이해하기

타입스크립트는 알아서 의존성 문제를 해결해 주기는커녕, 의존성 관리를 오히려 더 복잡하게 만든다.  
타입스크립트를 사용하면 라이브러리의 버전, 타입 선언(@types)의 버전, 타입스크립트의 버전을 추가로 고려해야 한다.  
라이브러리의 버전과 @types의 버전이 맞도록 버전을 올리거나 내려야 한다.  
타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋다.

## 공개 API에 등장하는 모든 타입을 익스포트하기

공개 메서드에 등장한 어떤 형태의 타입이든 익스포트한다.  
익스포트하지 않은 타입은 Parameters와 ReturnType 제너릭 타입으로 추출할 수 있다.

## API 주석에 TSDoc 사용하기

타입스크립트 언어 서비스는 JSDoc(타입스크립트 관점에서는 TSDoc) 스타일을 지원한다.  
편집기는 함수가 호출되는 곳에서 함수에 붙어 있는 JSDoc 스타일의 주석을 툴팁으로 표시해 준다.  
@param과 @returns를 추가하면 함수를 호출하는 부분에서 각 매개변수와 관련된 설명을 보여 준다.  
TSDoc 주석은 마크다운 형식으로 꾸며지므로 굵은 글씨, 기울임 글씨, 글머리기호 목록을 사용할 수 있다.

## 콜백에서 this에 대한 타입 제공하기

작성 중인 라이브러리에 this를 사용하는 콜백 함수가 있다면, this 바인딩 문제를 고려해야 한다.  
이 문제는 콜백 함수의 매개변수에 this를 추가하고, 콜백 함수를 call로 호출해서 해결할 수 있다.  
콜백 함수에서 this를 사용해야 한다면, 타입 정보를 명시해야 한다.

## 오버로딩 타입보다는 조건부 타입을 사용하기

오버로딩 타입이 작성하기는 쉽지만, 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더 정확해진다.  
각각의 오버로딩 타입은 독립적으로 처리되는 반면, 조건부 타입은 타입 체커가 단일 표현식으로 받아들이기 때문에 유니온 문제를 해결할 수 있다.

## 의존성 분리를 위해 미러 타입 사용하기

작성 중인 라이브러리가 의존하는 라이브러리의 구현과 무관하게 타입에만 의존한다면, 필요한 선언부만 추출하여 작성 중인 라이브러리에 넣는 것(미러링)을 고려해 보는 것이 좋다.  
필수가 아닌 의존성을 분리할 때는 구조적 타이핑을 사용하면 된다.  
공개한 라이브러리를 사용하는 자바스크립트 사용자가 @types 의존성을 가지지 않게 해야 한다. 그리고 웹 개발자가 NodeJS 관련된 의존성을 가지지 않게 해야 한다.

## 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않는다.  
타입스크립트의 역할을 명확하게 하려면 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋다.

## 객체를 순회하는 노하우

객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 `let k: keyof T`와 for-in 루프를 사용하면 된다.  
함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심해야 한다.  
객체를 순회하면 키와 값을 얻는 가장 일반적인 방법은 Object.entries를 사용하는 것이다.

## DOM 계층 구조 이해하기

타입스크립트에서는 DOM 엘리먼트의 계층 구조를 파악하기 용이합니다.  
Element와 EventTarget에 달려 있는 Node의 구체적인 타입을 안다면 타입 오류를 디버깅할 수 있고, 언제 타입 단언을 사용해야 할지 알 수 있습니다.  
DOM 엘리먼트와 이벤트에는 충분히 구체적인 타입 정보를 사용하거나, 타입스크립트가 추론할 수 있도록 문맥 정보를 활용해야 한다.

| 타입              | 예시                         |
| ----------------- | ---------------------------- |
| EventTarget       | window, XMLHttpRequest       |
| Node              | document, Text, Comment      |
| Element           | HTMLElement, SVGElement 포함 |
| HTMLElement       | `<i>`, `<b>`                 |
| HTMLButtonElement | `<button>`                   |

## 정보를 감추는 목적으로 private 사용하지 않기

public, protected, private 접근 제어자는 타입 시스템에서만 강제될 뿐이다.  
런타임에는 소용이 없으며 단언문을 통해 우회할 수 있다.  
접근 제어자로 데이터를 감추려고 해서는 안 된다.  
확실히 데이터를 감추고 싶다면 클로저를 사용해야 한다.

## 소스맵을 사용하여 타입스크립트 디버깅하기

원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅하지 말고 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅해야 한다.  
소스맵이 최종적으로 변환된 코드에 완전히 매핑되었는지 확인한다.  
소스맵에 원본 코드가 그대로 포함되도록 설정되어 있을 수도 있기 때문에 공개되지 않도록 설정을 확인해야 한다.

## 모던 자바스크립트로 작성하기

타입스크립트 개발 환경은 모던 자바스크립트도 실행할 수 있으므로 모던 자바스크립트의 최신 기능들을 적극적으로 사용해야 한다.  
모던 자바스크립트로 작성하면 코드 품질을 향상시킬 수 있고, 타입스크립트의 타입 추론도 더 나아진다.  
'use 'strict'는 타입스크립트 컴파일러 수준에서 사용되므로 코드에서 제거해야 한다.

## 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기

파일 상단에 `// @ts-check`를 추가하면 자바스크립트에서도 타입 체크를 수행할 수 있다.  
JSDoc 주석으로 타입 단언과 타입 추론을 할 수 있다.  
JSDoc 주석은 중간 단계이기 때문에 너무 공들일 필요는 없다. 최종 목표는 .ts로 된 타입스크립트 코드임을 명심해야 한다.

## 의존성 관계에 따라 모듈 단위로 전환하기

마이그레이션의 첫 단계는 서드파티 모듈과 외부 API 호출에 대한 @types를 추가하는 것이다.  
의존성 관계도의 아래에서부터 위로 올라가며 마이그레이션을 하면 된다. 보통 첫 번째 모듈은 유틸리티 모듈이다. 의존성 관계도를 시각화하여 진행 과정을 추적하는 것이 좋다.  
이상한 설계를 발견하더라도 리팩터링을 하면 안된다. 마이그레이션 작업은 타입스크립트 전환에 집중해야 하며, 나중의 리팩터링을 위해 목록을 만들어 두는 것이 좋다.  
타입스크립트로 전환하며 발견하게 되는 일반적인 오류들을 놓치지 않아야 한다. 타입 정보를 유지하기 위해 필요에 따라 JSDoc 주석을 활용해야 할 수도 있다.

## 마이그레이션의 완성을 위해 noImplicitAny 설정하기

noImplicitAny 설정을 활성화하여 마이그레이션의 마지막 단계를 진행해야 한다.  
noImplicitAny 설정이 없다면 타입 선언과 관련된 실제 오류가 드러나지 않는다.  
noImplicitAny를 전면 적용하기 전에 로컬에서부터 타입 오류를 점진적으로 수정해야 한다.
