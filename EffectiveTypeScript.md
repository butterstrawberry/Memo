# 이펙티브 타입스크립트

## 목차

- [타입스크립트와 자바스크립트의 관계 이해하기](#타입스크립트와-자바스크립트의-관계-이해하기)
- [타입스크립트 설정 이해하기](#타입스크립트-설정-이해하기)
- [코드 생성과 타입이 관계없음을 이해하기](#코드-생성과-타입이-관계없음을-이해하기)
- [구조적 타이핑에 익숙해지기](#구조적-타이핑에-익숙해지기)
- [any 타입 지양하기](#any-타입-지양하기)
- [편집기를 사용하여 타입 시스템 탐색하기](#편집기를-사용하여-타입-시스템-탐색하기)
- [타입이 값들의 집합이라고 생각하기](#타입이-값들의-집합이라고-생각하기)
- [타입 공간과 값 공간의 심벌 구분하기](#타입-공간과-값-공간의-심벌-구분하기)
- [타입 단언보다는 타입 선언을 사용하기](#타입-단언보다는-타입-선언을-사용하기)
- [잉여 속성 체크의 한계 인지하기](#잉여-속성-체크의-한계-인지하기)
- [함수 표현식에 타입 적용하기](#함수-표현식에-타입-적용하기)

## 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 자바스크립트의 상위집합이다.  
자바스크립트 프로그램에 문법 오류가 없다면, 유효한 타입스크립트 프로그램이라고 할 수 있다.  
모든 자바스크립트 프로그램이 타입스크립트라는 명제는 참이지만, 그 반대는 성립하지 않는다.  
자바스크립트의 런타임 동작을 모델링하는 것은 타입스크립트 타입 시스템의 기본 원칙이다.  
타입 시스템이 정적 타입의 정확성을 보장하지 않는다.

## 타입스크립트 설정 이해하기

tsconfig.json 설정 파일을 사용하는 것이 좋다.  
설정을 제대로 사용하려면, noImplicitAny와 strictNullChecks를 이해해야 한다.  
noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.  
strictNullChecks는 null과 undefined가 모든 타입에서 혀용되는지 확인하는 설정이다.  
프로젝트가 거대해질수록 설정 변경은 어려워질 것이므로, 가능한 한 초반에 설정하는 게 좋다.  
타입스크립트에 strict 설정을 하면 대부분의 오류를 잡아낸다.

## 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러의 트랜스파일과 타입 체크는 독립적으로 수행된다.  
타입 오류가 있는 코드도 컴파일이 가능하다.  
런타임에는 타입 체크가 불가능하다.  
런타임에 타입 정보를 손쉽게 유지하기 위해 태그된 유니온 기법을 사용한다.  
타입과 값을 둘 다 사용하는 방법으로는 타입을 클래스로 만드는 것이다.  
타입 연산은 런타임에 영향을 주지 않는다.  
런타임 타입은 선언된 타입과 다를 수 있다.  
타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

## 구조적 타이핑에 익숙해지기

자바스크립트는 덕 타이핑 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야 한다.  
함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하기 쉽다.  
타입은 좋든 싫든 열려있다.  
구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.

## any 타입 지양하기

any 타입에는 타입 안전성이 없다.  
any는 함수 시그니처를 무시해 버린다.  
any 타입에는 언어 서비스가 적용되지 않는다.  
any 타입은 코드 리팩터링 때 버그를 감춘다.  
any는 타입 설계를 감춰버린다.  
any는 타입시스템의 신뢰도를 떨어뜨린다.

## 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 컴파일러와 서버를 실행할 수 있다.  
서버에서 언어 서비스를 제공한다. 언어 서비스는 코드 자동 완성, 명세 검사, 검색, 리팩터링이 포함된다.  
보통은 편집기를 통해서 언어 서비스를 사용하는데, 서버에서 언어 서비스를 제공하도록 설정하는 게 좋다.  
편집기는 코드를 빌드하고 타입 시스템을 익힐 수 있는 최고의 수단이다.  
편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.  
추론 정보는 디버깅하는 데 꼭 필요하다.  
타입 선언은 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링되었는지, 어떻게 오류를 찾아낼지 살펴볼 수 있는 훌륭한 수단이다.

## 타입이 값들의 집합이라고 생각하기

타입을 값의 집합으로 생각하면 이해하기 편하다.  
타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 벤 다이어그램으로 표현된다.  
타입 연산은 집합의 범위에 적용된다.  
객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.  
'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분 집합'과 같은 의미다.

## 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.  
모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.  
연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 타입 단언보다는 타입 선언을 사용하기

타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.  
타입 선언문에서는 잉여 속성 체크가 동작했지만, 단언문에서는 적용되지 않는다.  
타입 단언은 타입 체커가 추론한 타입보다 여러분이 판단하는 타입이 더 정확할 때 의미가 있다.  
타입 단언문으로 임의의 타입 간에 변환을 할 수는 없고 부분 집합인 경우에 타입 단언문을 사용해 변환할 수 있다.

## 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 그 외의 속성은 없는지 확인한다.  
잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않을 수 있다.  
잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.  
약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다.  
잉여 속성 체크는 구조적 타이핑 시스템에서 혀용되는 속성 이름의 오타 같은 실수를 잡는 데 효과적인 방법이다.

## 함수 표현식에 타입 적용하기

타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.  
다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나, 동일한 타입 시그니처를 가지는 여러 개의 함수를 작성할 때는 함수 전체의 타입 선언을 적용해야 한다.  
다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.
