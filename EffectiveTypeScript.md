# 이펙티브 타입스크립트

## 목차

- [타입스크립트와 자바스크립트의 관계 이해하기](#타입스크립트와-자바스크립트의-관계-이해하기)
- [타입스크립트 설정 이해하기](#타입스크립트-설정-이해하기)
- [코드 생성과 타입이 관계없음을 이해하기](#코드-생성과-타입이-관계없음을-이해하기)
- [구조적 타이핑에 익숙해지기](#구조적-타이핑에-익숙해지기)
- [any 타입 지양하기](#any-타입-지양하기)
- [편집기를 사용하여 타입 시스템 탐색하기](#편집기를-사용하여-타입-시스템-탐색하기)
- [타입이 값들의 집합이라고 생각하기](#타입이-값들의-집합이라고-생각하기)
- [타입 공간과 값 공간의 심벌 구분하기](#타입-공간과-값-공간의-심벌-구분하기)
- [타입 단언보다는 타입 선언을 사용하기](#타입-단언보다는-타입-선언을-사용하기)
- [잉여 속성 체크의 한계 인지하기](#잉여-속성-체크의-한계-인지하기)
- [함수 표현식에 타입 적용하기](#함수-표현식에-타입-적용하기)
- [타입과 인터페이스의 차이점 알기](#타입과-인터페이스의-차이점-알기)
- [타입 연산과 제너릭 사용으로 반복 줄이기](#타입-연산과-제너릭-사용으로-반복-줄이기)
- [동적 데이터에 인덱스 시그니처 사용하기](#동적-데이터에-인덱스-시그니처-사용하기)
- [number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기](#number-인덱스-시그니처보다는-array-튜플-arraylike를-사용하기)
- [변경 관련된 오류 방지를 위해 readonly 사용하기](#변경-관련된-오류-방지를-위해-readonly-사용하기)
- [매핑된 타입을 사용하여 값을 동기화하기](#매핑된-타입을-사용하여-값을-동기화하기)
- [추론 가능한 타입을 사용해 장황한 코드 방지하기](#추론-가능한-타입을-사용해-장황한-코드-방지하기)
- [다른 타입에는 다른 변수 사용하기](#다른-타입에는-다른-변수-사용하기)
- [타입 넓히기](#타입-넓히기)
- [타입 좁히기](#타입-좁히기)
- [한꺼번에 객체 생성하기](#한꺼번에-객체-생성하기)
- [일관성 있는 별칭 사용하기](#일관성-있는-별칭-사용하기)
- [비동기 코드에는 콜백 대신 async 함수 사용하기](#비동기-코드에는-콜백-대신-async-함수-사용하기)
- [타입 추론에 문맥이 어떻게 사용되는지 이해하기](#타입-추론에-문맥이-어떻게-사용되는지-이해하기)
- [유효한 상태만 표현하는 타입을 지향하기](#유효한-상태만-표현하는-타입을-지향하기)
- [사용할 때는 너그럽게, 생성할 때는 엄격하게](#사용할-때는-너그럽게-생성할-때는-엄격하게)
- [문서에 타입 정보를 쓰지 않기](#문서에-타입-정보를-쓰지-않기)
- [타입 주변에 null 값 배치하기](#타입-주변에-null-값-배치하기)
- [유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기](#유니온의-인터페이스보다는-인터페이스의-유니온을-사용하기)
- [string 타입보다 더 구체적인 타입 사용하기](#string-타입보다-더-구체적인-타입-사용하기)
- [부정확한 타입보다는 미완성 타입을 사용하기](#부정확한-타입보다는-미완성-타입을-사용하기)
- [해당 분야의 용어로 타입 이름 짓기](#해당-분야의-용어로-타입-이름-짓기)
- [공식 명칭에는 상표를 붙이기](#공식-명칭에는-상표를-붙이기)
- [any 타입은 가능한 한 좁은 범위에서만 사용하기](#any-타입은-가능한-한-좁은-범위에서만-사용하기)
- [any를 구체적으로 변형해서 사용하기](#any를-구체적으로-변형해서-사용하기)

## 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 자바스크립트의 상위집합이다.  
자바스크립트 프로그램에 문법 오류가 없다면, 유효한 타입스크립트 프로그램이라고 할 수 있다.  
모든 자바스크립트 프로그램이 타입스크립트라는 명제는 참이지만, 그 반대는 성립하지 않는다.  
자바스크립트의 런타임 동작을 모델링하는 것은 타입스크립트 타입 시스템의 기본 원칙이다.  
타입 시스템이 정적 타입의 정확성을 보장하지 않는다.

## 타입스크립트 설정 이해하기

tsconfig.json 설정 파일을 사용하는 것이 좋다.  
설정을 제대로 사용하려면, noImplicitAny와 strictNullChecks를 이해해야 한다.  
noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.  
strictNullChecks는 null과 undefined가 모든 타입에서 혀용되는지 확인하는 설정이다.  
프로젝트가 거대해질수록 설정 변경은 어려워질 것이므로, 가능한 한 초반에 설정하는 게 좋다.  
타입스크립트에 strict 설정을 하면 대부분의 오류를 잡아낸다.

## 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러의 트랜스파일과 타입 체크는 독립적으로 수행된다.  
타입 오류가 있는 코드도 컴파일이 가능하다.  
런타임에는 타입 체크가 불가능하다.  
런타임에 타입 정보를 손쉽게 유지하기 위해 태그된 유니온 기법을 사용한다.  
타입과 값을 둘 다 사용하는 방법으로는 타입을 클래스로 만드는 것이다.  
타입 연산은 런타임에 영향을 주지 않는다.  
런타임 타입은 선언된 타입과 다를 수 있다.  
타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

## 구조적 타이핑에 익숙해지기

자바스크립트는 덕 타이핑 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야 한다.  
함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하기 쉽다.  
타입은 좋든 싫든 열려있다.  
구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.

## any 타입 지양하기

any 타입에는 타입 안전성이 없다.  
any는 함수 시그니처를 무시해 버린다.  
any 타입에는 언어 서비스가 적용되지 않는다.  
any 타입은 코드 리팩터링 때 버그를 감춘다.  
any는 타입 설계를 감춰버린다.  
any는 타입시스템의 신뢰도를 떨어뜨린다.

## 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 컴파일러와 서버를 실행할 수 있다.  
서버에서 언어 서비스를 제공한다. 언어 서비스는 코드 자동 완성, 명세 검사, 검색, 리팩터링이 포함된다.  
보통은 편집기를 통해서 언어 서비스를 사용하는데, 서버에서 언어 서비스를 제공하도록 설정하는 게 좋다.  
편집기는 코드를 빌드하고 타입 시스템을 익힐 수 있는 최고의 수단이다.  
편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.  
추론 정보는 디버깅하는 데 꼭 필요하다.  
타입 선언은 타입스크립트가 무엇을 하는지, 어떻게 라이브러리가 모델링되었는지, 어떻게 오류를 찾아낼지 살펴볼 수 있는 훌륭한 수단이다.

## 타입이 값들의 집합이라고 생각하기

타입을 값의 집합으로 생각하면 이해하기 편하다.  
타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 벤 다이어그램으로 표현된다.  
타입 연산은 집합의 범위에 적용된다.  
객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.  
'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분 집합'과 같은 의미다.

## 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.  
모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.  
연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 타입 단언보다는 타입 선언을 사용하기

타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.  
타입 선언문에서는 잉여 속성 체크가 동작했지만, 단언문에서는 적용되지 않는다.  
타입 단언은 타입 체커가 추론한 타입보다 여러분이 판단하는 타입이 더 정확할 때 의미가 있다.  
타입 단언문으로 임의의 타입 간에 변환을 할 수는 없고 부분 집합인 경우에 타입 단언문을 사용해 변환할 수 있다.

## 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 그 외의 속성은 없는지 확인한다.  
잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않을 수 있다.  
잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.  
약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다.  
잉여 속성 체크는 구조적 타이핑 시스템에서 혀용되는 속성 이름의 오타 같은 실수를 잡는 데 효과적인 방법이다.

## 함수 표현식에 타입 적용하기

타입스크립트에서는 함수 표현식을 사용하는 것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.  
다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나, 동일한 타입 시그니처를 가지는 여러 개의 함수를 작성할 때는 함수 전체의 타입 선언을 적용해야 한다.  
다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

## 타입과 인터페이스의 차이점 알기

타입과 인터페이스 사이에 존재하는 차이를 분명하게 알고, 같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야 한다.  
인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지는 못한다.  
type 키워드는 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에 활용되기도 한다.  
인터페이스로 튜플과 비슷하게 구현하면 concat 같은 메서드들을 사용할 수 없으므로 튜플은 type 키워드로 구현하는 것이 낫다.  
인터페이스는 선언 병합이 가능하다. 선언 병합은 주로 타입 선언 파일에서 사용된다.
프로젝트에서 어떤 문법을 사용할지 결정할 때 한 가지 일관된 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다.

## 타입 연산과 제너릭 사용으로 반복 줄이기

타입 중복은 코드 중복만큼 많은 문제를 발생시킨다.  
타입에 이름을 붙이거나 extends를 사용해서 인터페이스 필드의 반복을 피해야 한다.  
타입들 간의 매핑을 위해 타입스크립트가 제공한 도구들을 알면 좋다.  
타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋다.

## 동적 데이터에 인덱스 시그니처 사용하기

타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.  
인덱스 시그니처를 사용하면 잘못된 키를 포함해 모든 키를 허용하고 특정 키가 필요하지 않으며 키마다 다른 타입을 가질 수 없다. 또한 키는 무엇이든 가능하기 때문에 자동 완성 기능이 동작하지 않는다.  
런타임 때까지 객체의 속성을 알 수 없는 경우에만 인덱스 시그니처를 사용하도록 한다.  
안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 한다.  
인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

## number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

배열은 객체이므로 키는 숫자가 아니라 문자열이다.  
인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다.  
인덱스 시그니처에 number를 사용하기보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.

## 변경 관련된 오류 방지를 위해 readonly 사용하기

매개변수를 readonly로 선언하면 다음과 같은 일이 생긴다.

- 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크한다.
- 호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받게 된다.
- 호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수도 있다.

자바스크립트, 타입스크립트에서는 암묵적으로 함수가 매개변수를 변경하지 않는다고 가정한다. 그러나 이러한 암묵적인 방법은 타입 체크에 문제를 일으킬 수 있다.  
만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋다.  
readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있다.  
readonly는 얕게 동작한다는 것을 명심해야 한다.

## 매핑된 타입을 사용하여 값을 동기화하기

매핑된 타입을 사용해서 관련된 값과 타입을 동기화하도록 한다.  
인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 한다.

## 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입 추론이 된다면 명시적 타입 구문은 필요하지 않고 오히려 방해가 될뿐이다.  
타입스크립트에서 변수의 타입은 일반적으로 처음 등장할 때 결정된다.  
이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다.  
타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.  
보통 타입 정보가 있는 라이브러리에서, 콜백 함수의 매개변수 타입은 자동으로 추론된다.  
추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다.

## 다른 타입에는 다른 변수 사용하기

변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다.  
타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것이다.  
혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 한다.  
다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유는 다음과 같다.

- 서로 관련이 없는 두 개의 값을 분리한다.
- 변수명을 더 구체적으로 지을 수 있다.
- 타입 추론을 향상시키며, 타입 구문이 불필요해진다.
- 타입이 좀 더 간결해진다.
- let 대신 const로 변수를 선언하게 된다. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋다.

## 타입 넓히기

타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 가능한 값들의 집합인 타입을 가진다.  
지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추하는 과정을 넓히기라고 부른다.  
넓히기 과정을 제어할 수 있는 방법으로 const, 타입 구문, 타입 체커에 추가적인 문맥을 제공, as const가 있다.

## 타입 좁히기

타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.  
타입 체커는 일반적으로 조건문에서 타입 좁히기를 잘 해내지만, 타입 별칭이 존재한다면 그러지 못할 수도 있다.  
분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.  
instanceof, 속성 체크, Array.isArray로 타입을 좁힐 수 있다.  
태그된/구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원활하게 만들 수 있다.

## 한꺼번에 객체 생성하기

객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.  
객체를 반드시 제각각 나눠서 만들어야 한다면, 타입 단언문을 사용해 타입 체커를 통과하게 할 수 있다.  
작은 객체들을 조합해서 큰 객체를 만들어야 하는 경우에는 객체 전개 연산자를 사용하면 된다.  
타입에 안전한 방식으로 조건부 속성을 추가하려면, 속성을 추가하지 않는 null 또는 {}으로 객체 전개를 사용하면 된다.  
조건부 속성으로 하나의 속성을 추가하면 선택적 속성을 가진 것으로 추론되고 여러 속성을 추가하면 유니온으로 추론된다.

## 일관성 있는 별칭 사용하기

별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.  
비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.  
함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.

## 비동기 코드에는 콜백 대신 async 함수 사용하기

콜백보다는 프로미스를 사용하는 게 코드 작성과 타입 추론 면에서 유리하다.  
가능하면 프로미스를 생성하기보다는 async와 await를 사용하는 것이 좋다. 간결하고 직관적인 코드를 작성할 수 있고 모든 종류의 오류를 제거할 수 있다.  
어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.

## 타입 추론에 문맥이 어떻게 사용되는지 이해하기

타입스크립트는 타입을 추론할 때 단순히 값만 고려하지는 않고 값이 존재하는 곳의 문맥까지 살핀다.  
변수를 뽑아서 별도로 선언했을 때 오류가 발생한다면 타입 선언을 추가해야 한다.  
변수가 정말로 상수라면 상수 단언을 사용해야 한다. 그러나 상수 단언을 사용하면 정의한 곳이 아니라 사용한 곳에서 오류가 발생하므로 주의해야 한다.

## 유효한 상태만 표현하는 타입을 지향하기

유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.  
유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.

## 사용할 때는 너그럽게, 생성할 때는 엄격하게

함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.  
선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.  
매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하는 것이 좋다.

## 문서에 타입 정보를 쓰지 않기

주석과 변수명에 타입 정보를 적는 것은 피해야 한다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 된다.  
타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.

## 타입 주변에 null 값 배치하기

한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안 된다.  
API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 한다.  
클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다.

## 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기

유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의해야 한다.  
유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기도 좋다.  
타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 한다.

## string 타입보다 더 구체적인 타입 사용하기

모든 문자열을 할당할 수 있는 string 타입보다는 더 구체적인 타입을 사용하는 것이 좋다.  
변수의 범위를 보다 정확하게 표현하고 싶다면 string 타입보다는 문자열 리터럴 타입의 유니온을 사용하면 된다.  
객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T를 사용하는 것이 좋다.

## 부정확한 타입보다는 미완성 타입을 사용하기

타입 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생하기 쉽고 잘못된 타입은 차라리 타입이 없는 것보다 못할 수 있다.  
타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다.  
타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제는 더 커질 것이다.

## 해당 분야의 용어로 타입 이름 짓기

엄선된 타입, 속성, 변수의 이름은 의도를 명확히 하고 코드와 타입의 추상화 수준을 높여 준다.  
잘못 선택한 타입 이름은 코드의 의도를 왜곡하고 잘못된 개념을 심어 주게 된다.  
자체적으로 용어를 만들어 내려고 하지 말고, 해당 분야에 이미 존재하는 용어를 사용해야 한다.  
동일한 의미를 나타낼 때는 같은 용어를 사용해야 한다.  
모호하고 의미 없는 이름은 피해야 한다.  
이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려해야 한다.

## 공식 명칭에는 상표를 붙이기

타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 세밀하게 구분하지 못하는 경우가 있다. 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려해야 한다.  
상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다.  
타입 시스템이기 때문에 런타임 오버헤드를 없앨 수 있고 추가 속성을 붙일 수 없는 string이나 number 같은 내장 타입도 상표화할 수 있다.

## any 타입은 가능한 한 좁은 범위에서만 사용하기

의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.  
함수의 반환 타입이 any인 경우 타입 안정성이 나빠지므로 any 타입을 반환하면 절대 안 된다.  
강제로 타입 오류를 제거하려면 any 대신 @ts-ignore을 사용하는 것이 좋다.

## any를 구체적으로 변형해서 사용하기

일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재할 가능성이 높기 때문에 더 구체적인 타입을 찾아 타입 안전성을 높이도록 해야 한다.  
any보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[id: string]: any}` 또는 `() => any`처럼 구체적인 형태를 사용해야 한다.  
`{[id: string]: any}` 대신 모든 비기본형 타입을 포함하는 object 타입을 사용할 수도 있다. object 타입은 객체의 키를 열거할 수는 있지만 속성에 접근할 수 없다.
