# 러닝 타입스크립트

## 목차

- [타입스크립트란](#타입스크립트란)
- [타입 시스템](#타입-시스템)
- [유니언과 리터럴](#유니언과-리터럴)
- [객체](#객체)
- [함수](#함수)
- [배열](#배열)
- [인터페이스](#인터페이스)
- [클래스](#클래스)
- [타입 제한자](#타입-제한자)
- [제네릭](#제네릭)
- [선언 파일](#선언-파일)
- [IDE 기능 사용](#IDE-기능-사용)
- [구성 옵션](#구성-옵션)

## 타입스크립트란

타입스크립트는 종종 '자바스크립트의 상위 집합<sup>superset</sup>' 혹은 '타입이 있는 자바스크립트'로 설명되곤 한다.  
타입스크립트는 네 가지로 설명된다.

- 프로그래밍 언어: 자바스크립트의 모든 구문과, 타입을 정의하고 사용하기 위한 새로운 타입스크립트 고유 구문이 포함된 언어
- 타입 검사기: 자바스크립트 및 타입스크립트로 작성된 일련의 파일에서 생성된 모든 구성 요소를 이해하고, 잘못 구성된 부분을 알려주는 프로그램
- 컴파일러: 타입 검사기를 실행하고 문제를 보고한 후 이에 대응되는 자바스크립트 코드를 생성하는 프로그램
- 언어 서비스: 타입 검사기를 사용해 VS Code와 같은 편집기에 개발자에게 유용한 유틸리티 제공법을 알려주는 프로그램

## 타입 시스템

### 타입의 종류

'타입'은 자바스크립트에서 다루는 값의 **형태**에 대한 설명이다. 여기서 '형태'란 값에 존재하는 속성과 메서드 그리고 내장되어 있는 typeof 연산자가 설명하는 것을 의미한다.  
타입스크립트의 가장 기본적인 타입은 자바스크립트의 일곱 가지 기본 원시 타입<sup>primitive type</sup>과 동일하다.  
일곱 가지 원시 타입은 다음과 같다.

- null
- undefined
- boolean
- string
- number
- bigint
- symbol

### 타입 시스템

타입 시스템<sup>type system</sup>은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다.  
기본적으로 타입스크립트의 타입 시스템은 다음과 같이 작동한다.

1. 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인한다.
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다.

### 오류 종류

타입스크립트를 작성하는 동안 가장 자주 접하게 되는 오류로 구문 오류와 타입 오류가 있다.

#### _구문 오류_

구문 오류는 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생한다. 이는 타입스크립트가 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단한다.

#### _타입 오류_

타입 오류는 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지할 때 발생한다. 오류가 발생했다고 해서 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지는 않습니다.

### 할당 가능성

타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다. 나중에 해당 변수에 새로운 값이 할당되면, 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인하고 만약 다른 타입의 값이 할당되면 타입 오류가 발생한다.  
타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당 가능성**<sup>assignability</sup>이라고 한다. 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인한다.

### 타입 애너테이션

타입스크립트는 초깃값이 없는 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않는다. 그리고 기본적으로 변수를 암묵적인 any 타입으로 간주한다.  
초기 타입을 유추할 수 없는 변수는 **진화하는 any**라고 부른다. any 타입인 변수에 새로운 값이 할당될 때마다 변수의 타입이 변한다.  
타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입 애너테이션**<sup>type annotation</sup>을 제공한다.  
변수에 타입 애너테이션으로 정의한 타입 외의 값을 할당하면 타입 오류가 발생한다.

```typescript
let name: string;
name = "seeyoujeong";
```

#### _불필요한 타입 애너테이션_

타입스크립트가 타입을 유추할 수 있는 변수에 타입 애너테이션을 추가하면 중복이다.  
초깃값이 있는 변수에 타입 애너테이션을 추가하면 타입스크립트는 변수에 할당된 값의 타입이 일치하는지 확인한다.  
많은 개발자는 아무것도 변하지 않는 변수에 타입 애너테이션을 추가하지 않기를 선호한다.  
코드를 명확하게 문서화하거나 실수를 방지하기 위해 명시적으로 타입 애너테이션을 포함하는 것이 유용한 경우도 있다.

### 타입 형태

타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있다. 그리고 객체의 형태에 대한 이해를 바탕으로 할당 가능성뿐만 아니라 객체 사용과 관련된 문제도 알려준다.

#### _모듈_

타입스크립트는 최신 모듈(export 또는 import가 있는 파일) 파일을 기존 파일과 함께 실행할 수 있다.  
파일이 스크립트(모듈이 아닌 모든 파일)면 해당 파일을 전역 스코프로 간주한다. 따라서 동일한 이름의 변수가 동일한 파일에 선언된 것처럼 서로 충돌한다.  
강제로 모듈이 되도록 만들고 싶으면 파일의 아무 곳에나 export {};를 추가하면 된다.  
타입스크립트는 일반적으로 CommonJS 스타일의 require 함수에서 반환된 값을 any 타입으로 인식한다.

## 유니언과 리터럴

타입스크립트는 코드 정보에 입각한 추론을 수행하는 유니언<sup>union</sup>과 내로잉<sup>narrowing</sup>이라는 두 가지 개념이 있다.

### 유니언 타입

유니언 타입은 값이 정확히 어떤 타입인지 모르지만 두 개 이상의 옵션 중 하나라는 것을 알고 있는 경우에 코드를 처리하는 개념이다.  
타입스크립트는 가능한 값 또는 구성 요소 사이에 |(수직선) 연산자를 사용해 유니언 타입을 나타낸다.

#### _유니언 타입 선언_

변수의 초깃값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용한다.  
유니언 타입 선언은 타입 애너테이션으로 타입을 정의하는 모든 곳에서 사용할 수 있다.

#### _유니언 속성_

값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있다.  
유니언 타입으로 정의된 여러 타입 중 하나의 타입으로 된 값의 속성을 사용하려면 코드에서 값이 보다 구체적인 타입<sup>specific type</sup> 중 하나라는 것을 타입스크립트에 알려야 한다.

```typescript
let person = Math.random() > 0.5 ? "Jeong" : 20;

person.toString(); // Ok
person.toUpperCase(); // Error
person.toFixed(); // Error
```

### 내로잉

내로잉은 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것이다.  
타입을 좁히는 데 사용할 수 있는 논리적 검사를 타입 가드<sup>type guard</sup>라고 한다.

#### _값 할당을 통한 내로잉_

변수에 값을 직접 할당하면 타입스크립트는 변수의 타입을 할당된 값의 타입으로 좁힌다.  
변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 값 할당 내로잉이 작동한다.

#### _조건 검사를 통한 내로잉_

일반적으로 타입스크립트에서는 변수가 알려진 값과 같은지 확인하는 if 문을 통해 변수의 값을 좁히는 방법을 사용한다.  
타입스크립트는 if 문 내에서 변수가 알려진 값과 동일한 타입인지 확인한다.

#### _typeof 검사를 통한 내로잉_

타입스크립트는 직접 값을 확인해 타입을 좁히기도 하지만, typeof 연산자를 사용할 수도 있다.

### 리터럴 타입

리터럴 타입<sup>literal type</sup>은 좀 더 구체적인 버전의 원시 타입이다.  
원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입이 리터럴 타입이다.  
원시 타입은 해당 타입의 가능한 모든 리터럴 값의 집합이다.  
리터럴 타입은 그 값이 해당하는 원시 타입에 할당할 수 있다.

### 엄격한 null 검사

엄격한 null 검사는 다른 타입이 필요한 위치에서 null 값을 사용하지 못하도록 검사하는 것이다.  
엄격한 null 검사를 활성화해야만 코드가 null 또는 undefined 값으로 인한 오류로부터 안전한지 여부를 쉽게 파악할 수 있다.

#### _참 검사를 통한 내로잉_

타입스크립트는 잠재적인 값 중 truthy로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있다.  
논리 연산자인 &&와 ?는 참 여부를 검사하는 일을 잘 수행한다. 하지만 참 여부 확인 외에 다른 기능(빈 문자열인지 undefined인지)은 제공하지 않는다.

#### _초깃값이 없는 변수_

타입스크립트는 값이 할당될 때까지 변수가 undefined임을 이해할 만큼 충분히 영리하다.  
값이 할당되기 전에 속성 중 하나에 접근하려는 것처럼 해당 변수를 사용하려고 시도하면 '할당 전'이라는 오류 메시지가 나타난다.  
변수 타입에 undefined가 포함되어 있는 경우에는 오류가 보고되지 않는다.

### 타입 별칭

타입 별칭<sup>type alias</sup>은 **type 새로운 이름 = 타입** 형태를 갖는다. 편의상 타입 별칭은 파스칼 케이스로 이름을 지정한다.  
타입 별칭은 타입 시스템의 '복사해서 붙여넣기'처럼 작동한다.  
타입 별칭은 타입 애너테이션처럼 자바스크립트로 컴파일되지 않는다.  
타입 별칭은 다른 타입 별칭을 참조할 수 있고 사용 순서대로 선언할 필요는 없다.

## 객체

### 객체 타입

{...} 구문을 사용해서 객체 리터럴을 생성하면, 타입스크립트는 해당 속성을 기반으로 새로운 객체 타입 또는 타입 형태를 고려한다. 해당 객체 타입은 객체의 값과 동일한 속성명과 원시 타입을 갖는다.  
존재하지 않는 속성 이름으로 접근하려고 하면 해당 이름이 존재하지 않는다는 타입 오류가 발생한다.

### 객체 타입 선언

객체 타입은 객체 리터럴과 유사하게 보이지만 필드 값 대신 타입을 사용해 설명한다.

### 별칭 객체 타입

객체 타입에 타입 별칭을 할당해 사용하는 방법이 일반적이다.

```typescript
type User = {
  born: number;
  name: string;
};
```

### 구조적 타이핑

타입스크립트의 타입 시스템은 구조적으로 타입화<sup>structurally typed</sup>되어 있다. 이 말은 매개변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야 한다는 의미이다.  
구조적 타이핑은 덕 타이핑<sup>duck typing</sup>과는 다르다. 구조적 타이핑은 정적 시스템이 타입을 검사하는 경우이며, 덕 타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것을 말한다.

#### _사용 검사_

객체 타입으로 애너테이션된 위치에 값을 제공할 때 타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인한다.  
할당하는 값에는 객체 타입의 필수 속성이 있어야 하고 없으면 타입스크립트는 타입 오류를 발생시킨다.  
필수 속성 이름은 일치하고 타입이 일치하지 않으면 타입 오류를 발생시킨다.

#### _초과 속성 검사_

변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있다면 타입스크립트에서 타입 오류가 발생한다.  
초과 속성 검사는 객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어난다. 기존 객체 리터럴을 제공하면 초과 속성 검사를 우회한다.  
타입스크립트에서 초과 속성을 금지하면 코드를 깨끗하게 유지할 수 있고, 예상한 대로 작동하도록 만들 수 있다.

#### _선택적 속성_

타입의 속성 애너테이션에서 : 앞에 ?를 추가하면 선택적 속성임을 나타낼 수 있다.  
선택적 속성과 undefined를 포함한 유니언 타입의 속성 사이에는 차이가 있다. ?를 사용해 선택적으로 선언된 속성은 존재하지 않아도 되지만 필수로 선언된 속성과 | undefined는 그 값이 undefined일지라도 반드시 존재해야 한다.

### 객체 타입 유니언

타입스크립트 코드에서 속성이 조금 다른, 하나 이상의 서로 다른 객체 타입이 될 수 있는 타입을 설명할 수 있어야 한다.  
속성값을 기반으로 해당 객체 타입 간에 타입을 좁혀야 할 수도 있다.

#### _유추된 객체 타입 유니언_

변수에 여러 객체 타입 중 하나가 될 수 있는 초깃값이 주어지면 타입스크립트는 해당 타입을 객체 타입 유니언으로 유추한다.  
객체 타입에 정의된 각각의 가능한 속성은 비록 초깃값이 없는 선택적(?) 타입이지만 각 객체 타입의 구성 요소로 주어진다.

#### _명시된 객체 타입 유니언_

객체 타입의 조합을 명시하면 객체 타입을 더 명확히 정의할 수 있다.  
값의 타입이 객체 타입으로 구성된 유니언이라면 타입스크립트의 타입 시스템은 이런 모든 유니언 타입에 존재하는 속성에 대한 접근만 허용한다.

#### _객체 타입 내로잉_

코드에서 객체의 형태를 확인하고 타입 내로잉이 객체에 적용된다.  
존재하지 않는 객체의 속성에 접근하려고 시도하면 타입 가드처럼 작동하는 방식으로 사용되더라도 타입 오류로 간주된다.

#### _판별된 유니언_

객체의 속성이 객체의 형태를 나타내도록 하는 타입 형태를 판별된 유니언<sup>discriminated union</sup>이라 부르고, 객체의 타입을 가리키는 속성이 판별값이다.  
타입스크립트는 코드에서 판별 속성을 사용해 타입 내로잉을 수행한다.

```typescript
type PoemWithPages = {
  name: string;
  pages: number;
  type: "pages";
};

type PoemWithRhymes = {
  name: string;
  rhymes: boolean;
  type: "rhymes";
};
```

### 교차 타입

타입스크립트에서 & 교차 타입<sup>intersection type</sup>을 사용해 여러 타입을 동시에 나타낸다.  
교차 타입은 일반적으로 여러 기존 객체 타입을 별칭 객체 타입으로 결합해 새로운 타입을 생성한다.  
교차 타입을 사용할 때는 되도록 코드를 간결하게 유지해야 한다.  
교차 타입은 잘못 사용하기 쉽고 불가능한 타입(never)을 생성한다.  
원시 타입의 값은 동시에 여러 타입이 될 수 없기 때문에 교차 타입의 구성 요소로 함께 결합할 수 없다.

## 함수

### 함수 매개변수

함수 매개변수에 명시적 타입 정보가 선언되지 않으면 절대로 타입을 알 수 없다. 타입스크립트가 이를 any 타입으로 간주하며 매개변수의 타입은 무엇이든 될 수 있다.  
변수와 마찬가지로 타입스크립트를 사용하면 타입 애너테이션으로 함수 매개변수의 타입을 선언할 수 있다.

#### _필수 매개변수_

타입스크립트는 함수에 선언된 모든 매개변수가 필수라고 가정한다.  
함수가 잘못된 수의 인수로 호출되면, 타입스크립트는 타입 오류의 형태로 이의를 제기한다.  
함수에 필수 매개변수<sup>required parameter</sup>를 제공하도록 강제하면 예상되는 모든 인숫값을 함수 내에 존재하도록 만들어 타입 안정성을 강화하는 데 도움이 된다.

#### _선택적 매개변수_

타입스크립트에서는 선택적 객체 타입 속성과 유사하게 타입 애너테이션의 : 앞에 ?를 추가해 매개변수가 선택적이라고 표시한다.  
함수 호출에 선택적 매개변수<sup>optional parameter</sup>를 제공할 필요는 없다. 선택적 매개변수에는 항상 | undefined가 유니언 타입으로 추가되어 있다.  
함수에서 사용되는 모든 선택적 매개변수는 마지막 매개변수여야 한다. 필수 매개변수 전에 선택적 매개변수를 위치시키면 구문 오류가 발생한다.

#### _기본 매개변수_

타입스크립트의 타입 추론은 초기 변숫값과 마찬가지로 기본 함수 매개변수에 대해서도 유사하게 작동한다.  
매개변수에 기본값이 있고 타입 애너테이션이 없는 경우, 타입스크립트는 해당 기본값을 기반으로 매개변수 타입을 유추한다.

#### _나머지 매개변수_

타입스크립트는 나머지 매개변수<sup>rest parameter</sup>의 타입을 일반 매개변수와 유사하게 선언할 수 있다. 단, 인수 배열을 나타내기 위해 끝에 [] 구문이 추가된다는 점만 다르다.

### 반환 타입

타입스크립트는 지각적이라서 반환 타입<sup>return type</sup>을 가능한 모든 반환 타입의 조합으로 유추한다.

#### _명시적 반환 타입_

반환 타입 애너테이션은 매개변수 목록이 끝나는 ) 다음에 배치하고 화살표 함수의 경우 => 앞에 배치한다.  
함수의 반환문이 함수의 반환 타입으로 할당할 수 없는 값을 반환하는 경우 할당 가능성 오류를 표시한다.  
함수에서 반환 타입을 명시적으로 선언하는 방식이 유용할 때가 종종 있다.

- 가능한 반환값이 많은 함수가 항상 동일한 타입의 값을 반환하도록 강제하고 싶을 때
- 재귀 함수의 반환 타입을 통해 타입을 유추하는 것을 거부하고 싶을 때
- 매우 큰 프로젝트에서 타입 검사 속도를 높이고 싶을 때

### 함수 타입

함수 타입<sup>function type</sup> 구문은 화살표 함수와 유사하지만 함수 본문 대신 타입이 있다.  
함수 타입은 콜백 매개변수(함수로 호출되는 매개변수)를 설명하는 데 자주 사용된다.  
함수 타입에서도 타입 별칭을 사용할 수 있다.

#### _함수 타입 괄호_

함수 타입은 다른 타입이 사용되는 모든 곳에 배치할 수 있다. 여기에는 유니언 타입도 포함된다.  
유니언 타입의 애너테이션에서 함수 반환 위치를 나타내거나 유니언 타입을 감싸는 부분을 표시할 때 괄호를 사용한다.

```typescript
let returnStringOrUndefined: () => string | undefined;
let maybeReturnString: (() => string) | undefined;
```

#### _매개변수 타입 추론_

타입스크립트는 선언된 타입의 위치에 제공된 함수의 매개변수 타입을 유추할 수 있다.  
함수를 매개변수로 갖는 함수에 인수로 전달된 함수는 해당 매개변수 타입도 잘 유추할 수 있다.

### 그 외 반환 타입

#### _void 반환 타입_

타입스크립트는 void 키워드를 사용해 반환값이 없는 함수의 반환 타입을 확인할 수 있다.  
함수 타입을 선언할 때 void를 사용하면 함수에서 반환되는 모든 값은 무시된다.  
undefined를 포함하는 대신 void 타입의 값을 할당하려고 하면 타입 오류가 발생한다.  
void 타입은 자바스크립트가 아닌 함수의 반환 타입을 선언하는 데 사용하는 타입스크립트 키워드이다.

#### _never 반환 타입_

never를 반환하는 함수는 의도적으로 항상 오류를 발생시키거나 무한 루프를 실행하는 함수다.  
함수가 절대 반환하지 않도록 의도하려면 명시적 : never 타입 애너테이션을 추가해 해당 함수를 호출한 후 모든 코드가 실행되지 않음을 나타낸다.

### 함수 오버로드

함수 오버로드는 하나의 최종 구현 시그니처<sup>implementation signature</sup>와 그 함수의 본문 앞에 하나 이상의 오버로드 시그니처<sup>overload signature</sup>로 나타낼 수 있다.  
오버로드된 함수 호출에 대해 구문 오류를 생성할지 여부를 결정할 때 타입스크립트는 함수의 오버로드 시그니처만 확인한다.  
타입스크립트를 컴파일해 자바스크립트로 출력하면 다른 타입 시스템 구문처럼 오버로드 시그니처도 지워진다.  
함수를 단순하게 유지하고 가능하면 함수 오버로드를 사용하지 않는 것이 좋다.

#### _호출 시그니처 호환성_

함수의 오버로드 시그니처에 있는 반환 타입과 각 매개변수는 구현 시그니처에 있는 동일한 인덱스의 매개변수에 할당할 수 있어야 한다. 즉, 구현 시그니처는 모든 오버로드 시그니처와 호환되어야 한다.

## 배열

타입스크립트는 초기 배열에 어떤 데이터 타입이 있는지 기억하고, 배열이 해당 데이터 타입에서만 작동하도록 제한한다.

### 배열 타입

타입스크립트는 변수에 타입 애너테이션을 제공해 배열이 포함해야 하는 값의 타입을 알려주려고 한다. 배열에 대한 타입 애너테이션은 배열의 요소 타입 다음에 []가 와야 한다.
배열 타입은 Array<number> 같은 구문으로도 작성할 수 있지만 대부분 간단한 number[]를 선호한다.

#### _유니언 타입 배열_

배열의 각 요소가 여러 선택 타입 중 하나일 수 있음을 나타내려면 유니언 타입을 사용한다.  
유니언 타입으로 배열 타입을 사용할 때 애너테이션의 어느 부분이 배열의 콘텐츠이고 어느 부분이 유니언 타입 묶음인지를 나타내기 위해 괄호를 사용해야 한다.

```typescript
let stringOrArrayOfNumbers: string | number[];
let arrayOfStringOrNumbers: (string | number)[];
```

타입스크립트는 배열의 선언에서 두 가지 이상의 요소 타입이 포함되는 경우 유니언 타입 배열임을 알게 된다. 즉, 배열의 요소 타입은 배열에 담긴 요소에 대한 모든 가능한 타입의 집합이다.

```typescript
const nameMaybe = ["Jeong", undefined]; // (string | undefined)[]
```

### 배열 멤버

타입스크립트는 배열의 멤버를 찾아서 해당 배열의 타입 요소를 되돌려주는 전형적인 인덱스 기반 접근 방식을 이해하는 언어이다.  
유니언 타입으로 된 배열의 멤버는 그 자체로 동일한 유니언 타입이다.  
타입스크립트는 검색된 배열의 멤버가 존재하는지 의도적으로 확인하지 않는다.

### 튜플

고정된 크기의 배열인 튜블<sup>tuple</sup>은 각 인덱스에 알려진 특정 타입을 가지며 배열의 모든 가능한 멤버를 갖는 유니언 타입보다 더 구체적이다.  
튜플 타입을 선언하는 구문은 배열 리터럴처럼 보이지만 요소의 값 대신 타입을 적는다.

#### _튜플 할당 가능성_

타입스크립트에서 튜플 타입은 가변 길이의 배열 타입보다 더 구체적으로 처리되기 때문에 가변 길이의 배열 타입은 튜플 타입에 할당할 수 없다.  
타입스크립트는 튜플 타입의 튜플에 얼마나 많은 멤버가 있는지 알고 있기 때문에 길이가 다른 튜플은 서로 할당할 수 없다.

#### _나머지 매개변수로서의 튜플_

타입스크립트는 ... 나머지 매개변수로 전달된 튜플에 정확한 타입 검사를 제공할 수 있다.

```typescript
function logPair(name: string, value: number) { ... }

const pairTuple: [string, number] = ["Jeong", 1];

logPair(...pairTuple);
```

#### _튜플 추론_

타입스크립트는 생성된 배열을 튜플이 아닌 가변 길이의 배열로 취급한다.  
배열이 변수의 초깃값 또는 함수에 대한 반환값으로 사용되는 경우, 고정된 크기의 튜플이 아니라 유연한 크기의 배열로 가정한다.

#### _명시적 튜플 타입_

함수가 튜플 타입을 반환한다고 선언되고, 배열 리터럴을 반환한다면 해당 배열 리터럴은 일반적인 가변 길이의 배열 대신 튜플로 간주한다.

#### _const 어서션_

const 어서션은 타입스크립트에 타입을 유추할 때 읽기 전용<sup>read-only</sup>이 가능한 값 형식을 사용하도록 지시한다.  
const 어서션은 배열을 튜플로 전환하는 것을 넘어서, 해당 튜플이 읽기 전용이고 값 수정이 예상되는 곳에서 사용할 수 없음을 나타낸다.

## 인터페이스

인터페이스는 연관된 이름으로 객체를 설명하는 또 다른 방법이다.  
인터페이스는 별칭으로 된 객체 타입과 여러 면에서 유사하지만 일반적으로 더 읽기 쉬운 오류 메시지, 더 빠른 컴파일러 성능, 클래스와의 더 나은 상호 운용성을 위해 선호된다.

### 타입 별칭 vs 인터페이스

가능하다면 인터페이스를 사용하는 것이 좋고 타입 별칭은 유니언 타입과 같은 기능이 필요할 때 사용해야 한다.  
타입 별칭과 인터페이스 사이에 주요 차이점은 다음과 같다.

- 인터페이스는 속성 증가를 위한 병합<sup>merge</sup>을 할 수 있다.
- 인터페이스는 클래스가 선언된 구조의 타입을 확인하는 데 사용할 수 있다.
- 일반적으로 인터페이스에서 타입스크립트 타입 검사기가 더 빨리 작동한다.(명명된 타입을 선언)
- 인터페이스는 이름 없는 객체 리터럴의 별칭이 아닌 이름 있는 객체로 간주되므로 오류 메시지를 좀 더 쉽게 읽을 수 있다.

### 속성 타입

인터페이스와 타입 별칭은 매우 비슷하게 작동하므로 아래에 소개되는 속성 타입은 별칭 객체 타입에도 사용할 수 있다.

#### _선택적 속성_

타입 애너테이션 : 앞에 ?를 사용해 인터페이스의 속성이 선택적 속성임을 나타낼 수 있다.

#### _읽기 전용 속성_

타입스크립트는 속성 이름 앞에 readonly 키워드를 추가해 다른 값으로 설정될 수 없음을 나타낸다.  
readonly 제한자<sup>modifier</sup>는 객체의 인터페이스를 선언하는 위치에서만 사용되고 실제 객체에는 적용되지 않는다.  
readonly는 단지 타입스크립트 타입 검사기를 사용해 개발 중에 그 속성이 수정되지 못하도록 보호하는 역할을 한다.

#### _함수와 메서드_

타입스크립트는 인터페이스 멤버를 함수로 선언하는 두 가지 방법을 제공한다.

- 메서드 구문: 인터페이스 멤버를 member(): void와 같이 객체의 멤버로 호출되는 함수로 선언
- 속성 구문: 인터페이스의 멤버를 member: () => void와 같이 독립 함수와 동일하게 선언

두 가지 방법 모두 선택적 속성 키워드인 ?를 사용해 필수로 제공하지 않아도 되는 멤버로 나타낼 수 있다.

```typescript
interface OptionalFunctions {
  optionalProperty?: () => string;
  optionalMethod?(): string;
}
```

메서드와 속성 선언은 대부분 서로 교환하여 사용할 수 있지만 다음과 같은 차이점이 있다.

- 메서드는 readonly로 선언할 수 없지만 속성은 가능하다.
- 인터페이스 병합은 메서드와 속성을 다르게 처리한다.
- 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리한다.

타입스크립트의 향후 버전에서는 메서드와 속성 함수의 차이점에 대해 더 엄격한 옵션을 추가할 수도 있다. 그렇기 때문에 현시점에서는 기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수를 사용하고 나머지 경우에는 속성 함수를 사용하는 것이 좋다.

#### _호출 시그니처_

호출 시그니처<sup>call signature</sup>는 값을 함수처럼 호출하는 방식에 대한 타입 시스템의 설명이다.  
호출 시그니처가 선언한 방식으로 호출되는 값만 인터페이스에 할당할 수 있다. 즉, 할당 가능한 매개변수와 변환 타입을 가진 함수다.  
인터페이스와 객체 타입은 호출 시그니처로 선언할 수 있다.  
호출 시그니처는 사용자 정의 속성을 추가로 갖는 함수를 설명하는 데 사용할 수 있다.  
타입스크립트는 함수 선언에 추가된 속성을 해당 함수 선언의 타입에 추가하는 것으로 인식한다.

```typescript
type FunctionAlias = (input: string) => number;

interface CallSignature {
  (input: string): number;
}
```

#### _인덱스 시그니처_

타입스크립트는 인덱스 시그니처<sup>index signature</sup> 구문을 제공해 인터페이스의 객체가 임의의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타낸다.  
인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 타입 안정성을 완벽하게 보장하지는 않고 객체가 어떤 속성에 접근하든 간에 값을 반환해야 함을 나타낸다.  
키/값 쌍을 저장하려고 하는데 키를 미리 알 수 없다면 Map을 사용하는 편이 더 안전하다.

```typescript
interface IndexSignature {
  [i: string]: number;
}
```

#### _속성과 인덱스 시그니처 혼합_

인터페이스는 명시적으로 명명된 속성과 포괄적인<sup>catchall</sup> 용도의 인덱스 시그니처를 한번에 포함할 수 있다.  
각각의 명명된 속성의 타입은 포괄적인 용도의 인덱스 시그니처로 할당할 수 있어야 한다.  
타입스크립트 인덱스 시그니처는 키로 string 대신 number 타입을 사용할 수 있지만, 명명된 속성은 그 타입을 포괄적인 용도의 string 인덱스 시그니처의 타입으로 할당할 수 있어야 한다.

### 인터페이스 확장

타입스크립트는 인터페이스가 다른 인터페이스의 모든 멤버를 복사해서 선언할 수 있는 확장된<sup>extend</sup> 인터페이스를 허용한다.  
확장할 인터페이스의 이름 뒤에 extends 키워드를 추가해서 다른 인터페이스를 확장한 인터페이스라는 걸 표시한다.  
인터페이스 확장은 프로젝트의 한 엔티티<sup>entity</sup> 타입이 다른 엔티티의 모든 멤버를 포함하는 상위 집합<sup>superset</sup>을 나타내는 실용적인 방법이다.

#### _재정의된 속성_

파생 인터페이스<sup>derived interface</sup>는 다른 타입으로 속성을 다시 선언해 기본 인터페이스의 속성을 재정의하거나 대체할 수 있다.  
속성을 재선언하는 대부분의 파생 인터페이스는 해당 속성을 유니언 타입의 더 구체적인 하위 집합으로 만들거나 속성을 기본 인터페이스의 타입에서 확장된 타입으로 만들기 위해 사용한다.

#### _다중 인터페이스 확장_

타입스크립트의 인터페이스는 여러 개의 다른 인터페이스를 확장해서 선언할 수 있다.  
파생 인터페이스 이름에 있는 extends 키워드 뒤에 쉼표로 인터페이스 이름을 구분해 사용하면 된다.

### 인터페이스 병합

두 개의 인터페이스가 동일한 이름으로 동일한 스코프에 선언된 경우, 선언된 모든 필드를 포함하는 더 큰 인터페이스가 코드에 추가된다.  
인터페이스 병합을 자주 사용하지는 않지만 외부 패키지 또는 내장된 전역 인터페이스를 보강하는 데 유용하다.

#### _이름이 충돌되는 멤버_

병합된 인터페이스는 타입이 다른 동일한 이름의 속성을 여러 번 선언할 수 없다.  
속성이 이미 인터페이스에 선언되어 있다면 나중에 병합된 인터페이스에서도 동일한 타입을 사용해야 한다.  
병합된 인터페이스는 동일한 이름과 다른 시그니처를 가진 메서드는 정의할 수 있다.

## 클래스

### 클래스 메서드

타입스크립트는 독립 함수를 이해하는 것과 동일한 방식으로 메서드를 이해한다.  
매개변수 타입에 타입이나 기본값을 지정하지 않으면 any 타입을 기본으로 갖는다.  
클래스 생성자는 매개변수와 관련하여 전형적인 클래스 메서드처럼 취급된다.

### 클래스 속성

타입스크립트에서 클래스의 속성을 읽거나 쓰려면 클래스에 명시적으로 선언해야 한다.  
클래스 속성은 인터페이스와 동일한 구문을 사용해 선언하고 선택적으로 타입 애너테이션이 붙는다.  
클래스 속성을 명시적으로 선언하면 타입스크립트는 클래스 인스턴스에서 무엇이 허용되고, 허용되지 않는지 빠르게 이해할 수 있다.

#### _함수 속성_

클래스의 멤버를 호출 가능한 함수로 선언하는 두 가지 구문이 있는데 하나는 메서드 접근 방식이고 나머지 하나는 값이 함수인 속성을 선언하는 방식이 있다.  
함수 속성에는 클래스 메서드와 독립 함수의 동일한 구문을 사용해 매개변수와 반환 타입을 지정할 수 있다. 결국 함수 속성은 클래스 멤버로 할당된 값이고, 그 값은 함수이다.

#### _초기화 검사_

엄격한 컴파일러 설정이 활성화된 상태에서 타입스크립트는 undefined 타입으로 선언된 각 속성이 생성자에서 할당되었는지 확인한다.  
엄격한 초기화 검사가 없다면, 비록 타입 시스템이 undefined 값에 접근할 수 없다고 말할지라도 클래스 인스턴스는 undefined 값에 접근할 수 있다.  
엄격한 초기화 검사를 적용하면 안 되는 속성인 경우에는 이름 뒤에 !를 추가해 검사를 비활성화하도록 설정한다. 이렇게 하면 타입스크립트에 속성이 처음 사용되기 전에 undefined 값이 할당된다.

#### _선택적 속성_

클래스는 선언된 속성 이름 뒤에 ?를 추가해 속성을 옵션으로 선언한다.  
선택적 속성은 | undefined를 포함하는 유니언 타입과 거의 동일하게 작동한다.

#### _읽기 전용 속성_

선언된 속성 이름 앞에 readonly 키워드를 추가해 속성을 읽기 전용으로 선언한다.  
readonly로 선언된 속성은 선언된 위치 또는 생성자에서 초깃값만 할당할 수 있다.  
원시 타입의 초깃값을 갖는 readonly로 선언된 속성은 값의 타입이 가능한 한 좁혀진 리터럴 타입으로 유추된다.

### 타입으로서의 클래스

타입 시스템에서의 클래스는 클래스 선언이 런타임 값과 타입 애너테이션에서 사용할 수 있는 타입을 모두 생성한다.  
타입스크립트는 클래스의 동일한 멤버를 모두 포함하는 모든 객체 타입을 클래스에 할당할 수 있는 것으로 간주한다.

### 클래스와 인터페이스

타입스크립트는 클래스 이름 뒤에 implements 키워드와 인터페이스 이름을 추가함으로써 클래스의 해당 인스턴스가 인터페이스를 준수한다고 선언할 수 있다.  
타입스크립트는 인터페이스에서 클래스의 메서드 또는 속성 타입을 유추하지 않는다.

```typescript
interface Learner {
  name: string;
  study(hours: number): void;
}

class Student implements Learner {
  name; // Error

  study(hours) {
    // Error
    console.log("study", hours);
  }
}
```

#### _다중 인터페이스 구현_

타입스크립트의 클래스는 다중 인터페이스를 구현해 선언할 수 있다.  
클래스에 구현된 인터페이스 목록은 인터페이스 이름 사이에 쉼표를 넣고, 개수 제한 없이 인터페이스를 사용할 수 있다.
두 개의 충돌하는 인터페이스를 구현하는 클래스를 선언하려고 하면 클래스에 하나 이상의 타입 오류가 발생한다.

### 클래스 확장

타입스크립트는 다른 클래스를 확장하거나 하위 클래스를 만드는 자바스크립트 개념에 타입 검사를 추가한다.

#### _할당 가능성 확장_

하위 클래스의 인스턴스는 기본 클래스의 모든 멤버를 가지므로 기본 클래스의 인스턴스가 필요한 모든 곳에서 사용할 수 있다.  
타입스크립트의 구조적 타입에 따라 하위 클래스의 모든 멤버가 동일한 타입의 기본 클래스에 이미 존재하는 경우 기본 클래스의 인스턴스를 하위 클래스 대신 사용할 수 있다.

#### _재정의된 생성자_

바닐라 자바스크립트와 마찬가지로 타입스크립트에서 하위 클래스는 자체 생성자를 정의할 필요가 없다.  
타입스크립트의 타입 검사기는 기본 클래스 생성자를 호출할 때 올바른 매개변수를 사용하는지 확인한다.  
타입스크립트는 super()를 호출하기 전에 this 또는 super에 접근하려고 하는 경우 타입 오류를 보고한다.

#### _재정의된 메서드_

하위 클래스의 메서드가 기본 클래스의 메서드에 할당될 수 있는 한 하위 클래스는 기본 클래스와 동일한 이름으로 새 메서드를 다시 선언할 수 있다.  
하위 클래스에 재정의된 메서드의 타입은 기본 메서드와 동일한 타입을 가져야한다.

#### _재정의된 속성_

하위 클래스는 새 타입을 기본 클래스의 타입에 할당할 수 있는 한 동일한 이름으로 기본 클래스의 속성을 명시적으로 다시 선언할 수 있다.  
속성을 다시 선언하는 대부분의 하위 클래스는 해당 속성을 유니언 타입의 더 구체적인 하위 집합으로 만들거나 기본 클래스 속성 타입에서 확장되는 타입으로 만든다.

```typescript
class Person {
  name: string | undefined;
  age?: number;
}

class Jeong extends Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    super();
    this.name = name;
    this.age = age;
  }
}
```

### 추상 클래스

추상화하려는 클래스 이름과 메서드 앞에 타입스크립트의 abstract 키워드를 추가한다.  
추상화 메서드 선언은 추상화 기본 클래스에서 메서드의 본문을 제공하는 것을 건너뛰고, 대신 인터페이스와 동일한 방식으로 선언된다.
추상 클래스를 직접 인스턴스화할 수 없다.
추상 클래스는 클래스의 세부 사항이 채워질 거라 예상되는 프레임워크에서 자주 사용된다.

```typescript
abstract class School {
  abstract getStudentTypes(): string[];
}

class Preschool extends School {
  getStudentTypes() {
    return ["preschooler"];
  }
}
```

### 멤버 접근성

타입스크립트의 멤버 접근성은 클래스 멤버의 선언 이름 앞에 다음 키워드 중 하나를 추가해 만든다.

- public(기본값): 모든 곳에서 누구나 접근 가능
- protected: 클래스 내부 또는 하위 클래스에서만 접근 가능
- private: 클래스 내부에서만 접근 가능

타입스크립트의 멤버 접근성은 타입 시스템에서만 존재하는 반면 자바스크립트 private 선언은 런타임에도 존재한다는 점이 주요 차이점이다.  
접근성 제한자는 readonly와 함께 표시할 수 있으며 접근성 키워드를 먼저 적어야 한다.

#### _정적 필드 제한자_

타입스크립트는 static 키워드를 단독으로 사용하거나 readonly와 접근성 키워드를 함께 사용할 수 있도록 지원한다.  
함께 사용할 경우 접근성 키워드, static, readonly 순으로 작성하면 된다.

## 타입 제한자

### top 타입

top 타입은 시스템에서 가능한 모든 값을 나타내는 타입이다. 즉, 모든 타입은 top 타입에 할당할 수 있다.

#### _any_

any 타입은 모든 타입의 위치에 제공될 수 있다는 점에서 top 타입처럼 작동할 수 있다.  
any는 타입스크립트가 해당 값에 대한 할당 가능성 또는 멤버에 대해 타입 검사를 수행하지 않도록 명시적으로 지시한다는 문제점을 갖는다.

#### _unknown_

타입스크립트에서 unknown 타입은 진정한 top 타입이다.  
unknown 타입과 any 타입의 주요 차이점으로는 타입스크립트는 unknown 타입의 값을 훨씬 더 제한적으로 취급한다는 점이다.

- 타입스크립트는 unknown 타입 값의 속성에 직접 접근할 수 없다.
- unknown 타입은 top 타입이 아닌 타입에는 할당할 수 없다.

타입스크립트가 unknown 타입에 접근할 수 있는 유일한 방법은 instanceof나 typeof 또는 타입 어서션을 사용하는 것처럼 값의 타입이 제한된 경우이다.

### 타입 서술어

타입스크립트에는 인수가 특정 타입인지 여부를 나타내기 위해 boolean 값을 반환하는 함수를 위한 구문인 타입 서술어(type predicate)가 있다.  
타입 서술어는 일반적으로 매개변수로 전달된 인수가 매개변수의 타입보다 더 구체적인 타입인지 여부를 나타내는 데 사용된다.  
타입 서술어는 이미 한 인터페이스의 인스턴스로 알려진 객체가 더 구체적인 인터페이스의 인스턴스인지 여부를 검사하는 데 자주 사용된다.  
타입 서술어의 반환 타입은 매개변수의 이름, is 키워드, 특정 타입으로 선언할 수 있다.

```typescript
function typePredicate(input: WideType): input is NarrowType;
```

타입 서술어는 false 조건에서 타입을 좁히기 때문에 타입 서술어가 입력된 타입 이상을 검사하는 경우 예상치 못한 결과를 얻을 수 있음을 주의해야 한다.

### 타입 연산자

#### _keyof_

keyof 연산자는 기존에 존재하는 타입을 사용하고, 해당 타입에 허용되는 모든 키의 조합을 반환한다.  
타입 애너테이션처럼 타입을 사용하는 모든 곳에서 타입 이름 앞에 keyof 연산자를 배치한다.

#### _typeof_

typeof 연산자는 제공되는 값의 타입을 반환한다.  
typeof는 값의 타입을 수동으로 작성하는 것이 복잡한 경우에 사용하면 매우 유용하다.  
자바스크립트의 typeof 연산자와는 단지 우연히 같은 단어를 사용할 뿐이다.

#### _keyof typeof_

타입스크립트는 두 키워드를 함께 연결해 값의 타입에 허용된 키를 간결하게 검색할 수 있다.  
두 키워드를 결합해서 사용하면 명시적 인터페이스 타입이 없는 객체에 허용된 키를 나타내는 타입에 대한 코드를 작성하고 업데이트하는 수고를 줄일 수 있다.

### 타입 어서션

타입스크립트는 값의 타입에 대한 타입 시스템의 이해를 재정의하기 위한 구문으로 타입 어서션<sup>type assertion</sup>(타입 캐스트<sup>type cast</sup>라고도 부름)을 제공한다.  
다른 타입을 의미하는 값의 타입 다음에 as 키워드를 배치한다.  
타입 시스템은 어서션을 따르고 값을 해당 타입으로 처리한다.

#### _포착된 오류 타입 어서션_

일반적으로 catch 블록에서 포착된 오류가 어떤 타입인지 아는 것은 불가능하다.  
코드 영역이 Error 클래스의 인스턴스를 발생시킬 거라 틀림없이 확신한다면 타입 어서션을 사용해 포착된 어서션을 오류로 처리할 수 있다.  
발생된 오류가 예상된 오류 타입인지를 확인하기 위해 instanceof 검사와 같은 타입 내로잉을 사용하는 것이 더 안전하다.

#### _non-null 어서션_

null 또는 undefined를 포함할 수 있는 변수에서 null과 undefined를 제거할 때 타입 어서션을 주로 사용한다.  
null과 undefined를 제외한 값의 전체 타입을 작성하는 대신 !를 사용하면 된다.

#### _타입 어서션 주의 사항_

값의 타입에 대해 더 쉽게 어서션하는 것보다 코드를 나타내는 더 정확한 타입을 갖는 것이 좋다.  
코드베이스가 변경됨에 따라 나중에 런타임 오류가 발생할 수 있다.  
타입 어서션은 타입스크립트에 타입 검사 중 일부를 건너뛰도록 명시적으로 지시한다.  
타입스크립트는 타입 중 하나가 다른 타입에 할당 가능한 경우에만 두 타입 간의 타입 어서션을 허용한다.  
하나의 타입에서 값을 완전히 관련 없는 타입으로 전환해야 하는 경우 이중 타입 어서션을 사용할 수 있다.

```typescript
let doubleTypeAssertion = "1337" as unknown as number; // 허용되지만 이렇게 사용하면 안됨
```

### const 어서션

const 어서션은 배열, 원시 타입, 값, 별칭 등 모든 값을 상수로 취급해야 함을 나타내는 데 사용한다.  
as const는 수신하는 모든 타입에 다음 세 가지 규칙을 적용한다.

- 배열은 가변 배열이 아니라 읽기 전용 튜플로 취급된다.
- 리터럴은 일반적인 원시 타입과 동등하지 않고 리터럴로 취급된다.
- 객체의 속성은 읽기 전용으로 간주된다.

#### _리터럴에서 원시 타입으로_

타입 시스템이 리터럴 값을 일반적인 원시 타입으로 확장하기보다 특정 리터럴로 이해하는 것이 유용할 수 있다.  
값의 특정 필드가 더 구체적인 리터럴 값을 갖도록 하는 것도 유용하다.

#### _읽기 전용 객체_

값 리터럴에 const 어서션을 적용하면 해당 값 리터럴이 변경되지 않고 모든 멤버에 동일한 const 어서션 로직이 재귀적으로 적용된다.

## 제네릭

타입스크립트는 제네릭<sup>generic</sup>을 사용해 타입 간의 관계를 알아낸다.  
함수와 같은 구조체는 제네릭 타입 매개변수를 원하는 수만큼 선언할 수 있다.  
타입 매개변수는 구조체의 각 인스턴스에 대해 타입 인수라고 하는 서로 다른 타입을 함께 제공할 수 있지만, 타입 인수가 제공된 인스턴스 내에서는 일관성을 유지한다.  
타입 매개변수는 일반적으로 T나 U 같은 단일 문자 이름 또는 파스칼 케이스 이름을 갖는다.

### 제네릭 함수

매개변수 괄호 바로 앞 홑화살괄호(<, >)로 묶인 타입 매개변수에 별칭을 배치해 함수를 제네릭으로 만든다.  
해당 타입 매개변수를 함수의 본문 내부의 매개변수 타입 애너테이션, 반환 타입 애너테이션, 타입 애너테이션에서 사용할 수 있다.  
화살표 함수의 제네릭 선언은 매개변수 목록 바로 전인 ( 앞에 위치한다.  
함수에 타입 매개변수를 추가하면 타입 안정성을 유지하고 any타입을 피하면서 다른 입력과 함께 재사용할 수 있다.

#### _명시적 제네릭 호출 타입_

제네릭 함수를 호출할 때 대부분의 타입스크립트는 함수가 호출되는 방식에 따라 타입 인수를 유추한다.  
기본값이 unknown으로 설정되는 것을 피하기 위해 타입스크립트에 해당 타입 인수가 무엇인지 명시적으로 알려주는 명시적 제네릭 타입 인수를 사용해 함수를 호출할 수 있다.  
타입스크립트는 매개변수가 타입 인수로 제공된 것과 일치하는지 확인하기 위해 제네릭 호출에서 타입 검사를 수행한다.

```typescript
function logWrapper<Input>(callback: (input: Input) => void) {
  return (input: Input) => {
    console.log("Input: ", input);
    callback(input);
  };
}

logWrapper<string>((input) => {
  console.log(input.length);
});
```

#### _다중 함수 타입 매개변수_

임의의 수의 타입 매개변수를 쉼표로 구분해 함수를 정의한다.  
제네릭 함수의 각 호출은 각 타입 매개변수에 대한 자체 값 집합을 확인할 수 있다.  
함수가 여러 개의 타입 매개변수를 선언하면 해당 함수에 대한 호출은 명시적으로 제네릭 타입을 모두 선언하지 않거나 모두 선언해야 한다.  
제네릭 구조체에서 두 개보다 많은 타입 매개변수를 사용하는 것은 자제해야 한다.

### 제네릭 인터페이스

인터페이스는 함수와 유사한 제네릭 규칙을 따르며 인터페이스 이름 뒤 <과 > 사이에 선언된 임의의 수의 타입 매개변수를 갖는다.  
해당 제네릭 타입은 나중에 멤버 타입과 같이 선언의 다른 곳에서 사용할 수 있다.

#### _유추된 제네릭 인터페이스 타입_

제네릭 함수와 마찬가지로 제네릭 인터페이스의 타입 인수는 사용법에서 유추할 수 있다.  
타입스크립트는 제네릭 타입을 취하는 것으로 선언된 위치에 제공된 값의 타입에서 타입 인수를 유추한다.  
인터페이스가 타입 매개변수를 선언하는 경우, 해당 인터페이스를 참조하는 모든 타입 애너테이션은 이에 상응하는 타입 인수를 제공해야 한다.

### 제네릭 클래스

인터페이스처럼 클래스도 나중에 멤버에서 사용할 임의의 수의 타입 매개변수를 선언할 수 있다.  
클래스의 각 인스턴스는 타입 매개변수로 각자 다른 타입 인수 집합을 가진다.  
클래스를 사용하는 타입 애너테이션은 해당 클래스의 제네릭 타입이 무엇인지를 타입스크립트에 나타내야 한다.

#### _명시적 제네릭 클래스 타입_

제네릭 클래스 인스턴스화는 제네릭 함수를 호출하는 것과 동일한 타입 인수 유추 규칙을 따른다.  
생성자에 전달된 인수에서 클래스 타입 인수를 유추할 수 없는 경우에는 타입 인수의 기본값은 unknown이 된다.

#### _제네릭 클래스 확장_

타입스크립트는 사용법에서 기본 클래스에 대한 인수를 유추하지 않는다.  
기본값이 없는 모든 타입 인수는 명시적 타입 애너테이션을 사용해 지정해야 한다.  
제네릭 파생 클래스는 자체 타입 인수를 기본 클래스에 번갈아 전달할 수 있다.

#### _제네릭 인터페이스 구현_

제네릭 클래스는 모든 필요한 매개변수를 제공함으로써 제네릭 인터페이스를 구현한다.  
제네릭 인터페이스는 제네릭 기본 클래스를 확장하는 것과 유사하게 작동한다.  
기본 인터페이스의 모든 타입 매개변수는 클래스에 선언되어야 한다.

```typescript
interface ActingCredit<Role> {
  role: Role;
}

class MoviePart implements ActingCredit<string> {
  role: string;

  constructor(role: string) {
    this.role = role;
  }
}
```

#### _메서드 제네릭_

클래스 메서드는 클래스 인스턴스와 별개로 자체 제네릭 타입을 선언할 수 있다.  
제네릭 클래스 메서드에 대한 각각의 호출은 각 타입 매개변수에 대해 다른 타입 인수를 갖는다.

#### _정적 클래스 제네릭_

정적 클래스 메서드는 자체 타입 매개변수를 선언할 수 있지만 클래스에 선언된 어떤 타입 매개변수에도 접근할 수 없다.

### 제네릭 타입 별칭

제네릭 타입 별칭은 일반적으로 제네릭 함수의 타입을 설명하는 함수와 함께 사용된다.

```typescript
type CreateValue<Input, Output> = (input: Input) => Output;
```

#### _제네릭 판별된 유니언_

데이터의 성공적인 결과 또는 오류로 인한 실패를 나타내는 제네릭 '결과' 타입을 만들기 위해 타입 인수를 추가하는 방법이 있다.

```typescript
type Result<Data> = FailureResult | SuccessfulResult<Data>;

interface FailureResult {
  error: Error;
  succeeded: false;
}

interface SuccessfulResult<Data> {
  data: Data;
  succeeded: true;
}
```

### 제네릭 제한자

타입스크립트는 제네릭 타입 매개변수의 동작을 수정하는 구문도 제공한다.

#### _제네릭 기본값_

타입 매개변수 선언 뒤에 =와 기본 타입을 배치해 타입 인수를 명시적으로 제공할 수 있다.  
기본값은 타입 인수가 명시적으로 선언되지 않고 유추할 수 없는 모든 후속 타입에 사용된다.  
타입 매개변수는 동일한 선언 안의 앞선 타입 매개변수를 기본값으로 가질 수 있다.  
모든 기본 타입 매개변수는 기본 함수 매개변수처럼 선언 목록의 제일 마지막에 와야 한다.

### 제한된 제네릭 타입

타입스크립트는 타입 매개변수가 타입을 확장해야 한다고 선언할 수 있으며 별칭 타입에만 허용되는 작업이다.  
타입 매개변수를 제한하는 구문은 매개변수 이름 뒤에 extends 키워드를 배치하고 그 뒤에 이를 제한할 타입을 배치한다.

#### _keyof와 제한된 타입 매개변수_

extends와 keyof를 함께 사용하면 타입 매개변수를 이전 타입 매개변수의 키로 제한할 수 있다.  
제네릭 타입의 키를 지정하는 유일한 방법이다.

```typescript
function get<T, Key extends keyof T>(container: T, key: Key) {
  return container[key];
}
```

### Promise

Promise는 타입스크립트 타입 시스템에서 최종적으로 resolve된 값을 나타내는 단일 타입 매개변수를 가진 Promise 클래스로 표현된다.  
타입스크립트에서 Promise 생성자는 단일 매개변수를 받도록 작성된다.  
결과적으로 값을 resolve하려는 Promise를 만들려면 Promise의 타입 인수를 명시적으로 선언해야 한다.  
명시적 제네릭 타입 인수가 없다면 기본적으로 매개변수 타입을 unknown으로 가정한다.  
Promise의 제네릭 .then 메서드는 반환되는 Promise의 resolve된 값을 나타내는 새로운 타입 매개변수를 받는다.

#### _async 함수_

Promise를 명시적으로 언급하지 않더라도 async 함수에서 수동으로 선언된 반환 타입은 항상 Promise 타입이 된다.

### 제네릭 올바르게 사용하기

제네릭은 코드에서 타입을 설명하는 데 많은 유연성을 제공할 수 있지만, 코드가 빠르게 복잡해질 수 있다.  
타입스크립트의 모범 사례는 필요할 때만 제네릭을 사용하고, 제네릭을 사용할 때는 무엇을 위해 사용하는지 명확히 해야 한다.

#### _제네릭 황금률_

함수에 타입 매개변수가 필요한지 여부를 판단할 수 있는 간단하고 빠른 방법은 타입 매개변수가 최소 두 번 이상 사용되었는지 확인하는 것이다.  
제네릭은 타입 간의 관계를 설명하므로 제네릭 타입 매개변수가 한 곳에만 나타나면 여러 타입 간의 관계를 정의할 수 없다.  
따라서 각 함수 타입 매개변수는 매개변수에 사용되어야 하고, 그다음 적어도 하나의 다른 매개변수 또는 함수의 반환 타입에서도 사용되어야 한다.

#### _제네릭 명명 규칙_

타입스크립트를 포함한 많은 언어가 지키는 타입 매개변수에 대한 표준 명명 규칙<sup>naming convention</sup>은 기본적으로 첫 번째 타입 인수로 T를 사용하고, 후속 타입 매개변수가 존재하면 U, V 등을 사용하는 것이다.  
타입 인수가 어떻게 사용되어야 하는지 맥락과 관련된 정보가 알려진 경우 명명 규칙은 경우에 따라 해당 용어의 첫 글자를 사용하는 것으로 확장된다.  
구조체가 여러 개의 타입 매개변수를 갖거나 단일 타입 인수의 목적이 명확하지 않을 때마다 단일 문자 약어 대신 가독성을 위해 완전히 작성된 이름을 사용하는 것이 좋다.

## 선언 파일

타입스크립트 프로젝트에서 원시 자바스크립트 파일로 작업할 수 있어야 한다.  
타입스크립트 프로젝트는 전역 변수와 API 같은 환경에 특화된 기능의 타입 형태를 알려주는 방법이 필요하다.  
타입스크립트는 구현과 별도로 타입 형태를 선언할 수 있다.  
타입 선언은 파일 이름이 .d.ts 확장자로 끝나는 선언 파일<sup>declaration file</sup>에 작성된다.  
선언 파일은 일반적으로 프로젝트 내에서 작성되고, 프로젝트의 컴파일된 npm 패키지로 빌드 및 배포되거나 독립 실행형 typings 패키지로 공유 된다.

### 선언 파일

.d.ts 선언 파일은 런타임 코드를 포함할 수 없다는 주목할 만한 제약 사항을 제외하고 .ts 파일과 유사하게 작동한다.  
.d.ts 파일에는 사용 가능한 런타임 값, 인터페이스, 모듈, 일반적인 타입의 설명만 포함된다.  
.d.ts 파일은 자바스크립트로 컴파일할 수 있는 모든 런타임 코드를 포함할 수 없다.  
선언 파일은 다른 타입스크립트 파일과 마찬가지로 임포트해서 사용할 수 있다.  
선언 파일은 값이 아닌 타입만 선언할 수 있는 코드 영역을 의미하는 앰비언트 컨텍스트를 생성한다.

### 런타임 값 선언

declare 키워드를 사용해 함수 또는 변수의 구조체가 존재한다고 선언할 수 있다.  
declare로 변수를 선언하면 초깃값이 허용되지 않는다는 점을 제외하고 일반적인 변수 선언과 동일한 구문을 사용한다.  
함수와 클래스도 일반적인 형식과 유사하게 선언되지만 함수 또는 메서드의 본문이 없다.  
declare 키워드를 사용한 타입 선언은 .d.ts 선언 파일에서 사용하는 게 가장 일반적이지만, 선언 파일 외부에서도 사용할 수 있다.

#### _전역 변수_

전역 선언 파일은 애플리케이션의 모든 파일에 걸쳐서 사용할 수 있는 전역 타입 또는 변수를 선언하는 데 유용하다.  
전역으로 선언된 값은 전역 변수를 사용하는 브라우저 애플리케이션에서 가장 자주 사용된다.

#### _전역 인터페이스 병합_

인터페이스는 동일한 이름의 다른 인터페이스와 병합되기 때문에 import와 export 문이 없는 .d.ts 선언 파일 같은 전역 스크립트 컨텍스트에서 인터페이스를 선언하면 해당 인터페이스가 전역으로 확장된다.

#### _전역 확장_

타입스크립트에서 declare global 코드 블록 구문을 사용해 해당 블록 내용이 전역 컨텍스트에 있다고 표시한다.  
전역 선언과 모듈 선언이 함께 잘 작동하도록 랭글링<sup>wrangling</sup>하는 것은 까다로울 수 있다.

### 내장된 선언

#### _라이브러리 선언_

모든 자바스크립트 런타임에 존재하는 내장된 전역 객체는 lib.[target].d.ts 파일 이름으로 선언된다.  
내장된 라이브러리 선언 파일 또는 'lib 파일'은 자바스크립트의 내장된 API 전체를 나타내기 때문에 상당히 크다.  
타입스크립트는 기본적으로 tsc CLI 또는 프로젝트의 tsconfig.json(기본값은 es5)에서 제공된 target 설정에 따라 적절한 lib 파일을 포함한다.

#### _DOM 선언_

DOM 타입은 lib.dom.d.ts 파일과 다른 lib.\*.d.ts 선언 파일에도 저장된다.  
많은 내장 전역 타입처럼 전역 DOM 타입은 종종 전역 인터페이스로 설명된다.  
lib 컴파일러 옵션을 재정의하지 않는 타입스크립트 프로젝트는 DOM 타입을 기본으로 포함한다.

### 모듈 선언

모듈의 문자열 이름 앞에 declare 키워드를 사용하면 모듈의 내용을 타입 시스템에 알릴 수 있다.  
코드에서 declare module을 자주 사용해서는 안 된다.

```typescript
// modules.d.ts
declare module "my-example-lib" {
  export const value: string;
}

// index.ts
import { value } from "my-example-lib";

console.log(value);
```

#### _와일드카드 모듈 선언_

모듈 선언은 자바스크립트와 타입스크립트 파일 확장자가 아닌 특정 파일의 내용을 코드로 가져올 수 있음을 웹 애플리케이션에 알리기 위해 사용한다.  
모듈 선언으로 하나의 \* 와일드카드를 포함해 해당 패턴과 일치하는 모든 모듈을 나타낼 수 있다.  
와일드카드 모듈을 사용해 로컬 파일을 나타내는 방식이 타입 안정성을 완벽하게 보장하지 않는다.

### 패키지 타입

타입스크립트로 작성된 프로젝트는 여전히 .js로 컴파일된 파일이 포함된 패키지를 배포한다.  
일반적으로 .d.ts 파일을 사용해 이러한 자바스크립트 파일 뒤에 타입스크립트 타입 시스템 형태를 지원하도록 선언한다.

#### _선언_

타입스크립트는 입력된 파일에 대한 .d.ts 출력 파일과 자바스크립트 출력 파일을 함께 생성하는 선언 옵션을 제공한다.  
일반적으로 .js 파일을 생성하는 타입스크립트로 작성된 대부분의 패키지도 해당 파일과 함께 .d.ts를 번들로 묶는 것이 좋다.

#### _패키지 타입 의존성_

타입스크립트는 프로젝트의 node_modules 의존성 내부에서 번들로 제공되는 .d.ts 파일을 감지하고 활용할 수 있다.

#### _패키지 타입 노출_

프로젝트가 npm에 배포되고 사용자를 위한 타입을 제공하려면 패키지의 package.json 파일에 types 필드를 추가해 루트 선언 파일을 가리킨다.  
types 필드는 .d.ts 확장자를 사용하고 ./index.d.ts를 기본값으로 가정한다.

### DefinitelyTyped

타입스크립트 프로젝트는 여전히 해당 패키지에서 모듈의 타입 형태를 알려줘야 한다.  
타입스크립트 팀과 커뮤니티는 커뮤니티에서 작성된 패키지 정의를 수용하기 위해 DefinitelyTyped라는 거대한 저장소를 만들었다.  
저장소에는 변경 제안 검토 및 업데이트 게시와 관련된 자동화 부분과 수천 개의 .d.ts 정의 패키지가 포함되어 있다.

#### _타입 사용 가능성_

아직 사용 가능한 타입이 없는 패키지에서 타입을 얻는 일반적인 세 가지 옵션은 다음과 같다.

- @types/패키지를 생성하기 위해 DefinitelyTyped에 풀 리퀘스트를 보낸다.
- 앞서 소개한 declare module 구문을 사용해 프로젝트 내에서 타입을 작성한다.
- noImplicitAny 옵션을 비활성하고 강력하게 경고한다.

## IDE 기능 사용

### 코드 탐색

대부분의 개발자는 코드를 읽는 데 많은 시간을 보낸다.  
코드 탐색을 지원하는 도구를 이용하면 시간을 상당히 단축할 수 있다.

#### _정의 찾기_

타입스크립트는 타입 정의 또는 값에 대한 참조에서 시작해 코드의 원래 위치로 다시 이동할 수 있다.

- Go to Definition(F12)은 요청된 이름이 원래 정의된 위치로 즉시 이동한다.
- Cmd 혹은 Ctrl + 이름을 클릭하면 정의된 곳으로 이동한다.
- Peek -> Peek Definition(Option 혹은 Alt + F12)은 정의를 보여주는 Peek 상자를 불러온다.

#### _참조 찾기_

타입 정의 또는 값이 제공되면, 타입스크립트는 이에 대한 모든 참조 목록 또는 프로젝트에서 사용된 위치를 보여줄 수 있다.  
Go to Reference(Shift + F12)를 선택하면 마우스 오른쪽으로 클릭한 이름 바로 아래에 확장 가능한 Peek 상자가 나타나고, 해당 타입 정의 또는 값의 참조 목록을 보여준다.  
Find All References(Option 혹은 Alt + Shift + F12)는 참조 목록을 보여주고 코드 탐색 후에도 사이드바 뷰에서 확인 가능하다.

#### _구현 찾기_

Go to Implementations(Cmd 혹은 Ctrl + F12)와 Find All Implementations는 코드에서 인터페이스 또는 추상 메서드의 모든 구현을 찾는다.  
이 두 메뉴는 클래스 또는 인터페이스와 같은 타입으로 입력된 값이 어떻게 사용되는지를 구체적으로 검색할 때 특히 유용하다.  
구현 찾기와 참조 찾기의 차이는 참조 찾기에는 정의 및 기타 타입 참조도 보여주므로 복잡해 보인다는 것이다.

### 코드 작성

#### _이름 완성하기_

타입스크립트의 API를 이용하면 동일한 파일에 존재하는 이름을 자동 완성할 수 있다.  
패키지 의존성에 대해서도 자동 가져오기를 제공한다.  
타입이 지정된 값에서 속성 이름을 입력하기 시작하면 값의 타입의 알려진 속성을 자동 완성하도록 제안한다.

#### _자동 가져오기 업데이트_

VS Code 파일 탐색기를 사용해 파일을 드래그 앤드 드롭하거나 중첩된 폴더 경로로 이름을 바꾸면, VS Code에서 타입스크립트를 사용해 파일 경로를 업데이트하도록 제안한다.

#### _코드 액션_

타입스크립트의 많은 IDE 유틸리티는 직접 실행할 수 있는 액션으로 제공된다.  
편집기에서 코드 액션을 사용할 수 있다면 전구 아이콘이 나타난다.  
단축키는 Cmd 혹은 Ctrl + . 이다.

#### _이름 바꾸기_

타입스크립트는 이름에 대한 모든 참조를 업데이트하는 이름 바꾸기를 수행할 수 있다.  
메뉴의 Rename Symbol(F2) 옵션을 선택하면 새 이름을 입력할 수 있는 텍스트 상자가 나타난다.  
새 이름을 적용하기 전에 어떤 일이 발생하는지 보려면 Shift + Enter를 눌러서 리팩터링 미리보기 창을 열어 확인할 수 있다.

#### _사용하지 않는 코드 제거_

타입스크립트는 사용하지 않는 코드를 삭제하는 코드 액션을 제공한다.

#### _기타 빠른 수정_

- 클래스 또는 인터페이스에서 누락된 속성 선언하기
- 잘못 입력된 필드 이름 수정하기
- 타입으로 선언된 변수의 누락된 속성 채우기

### 오류를 효과적으로 처리하기

#### _PROBLEMS 탭_

PROBLEMS 탭은 작업 공간의 모든 문제를 나타낸다.  
PROBLEMS 탭에서 오류를 클릭하면 텍스트 커서가 문제가 되는 행과 열로 이동한다.  
VS Code는 현재 열려 있는 파일에 대한 오류만 나열한다.

#### _터미널 컴파일러 실행_

터미널에서 타입스크립트 컴파일러 watch 모드를 실행하면 모든 오류에 대한 실시간 업데이트 목록을 확인할 수 있다.  
VS Code에서 이 작업을 수행하려면, 터미널 패널을 열고 tsc -w를 실행한다.

#### _타입 이해_

복잡한 타입의 구성 요소를 이해할 때 유용한 한 가지 전략은 타입의 한 구성 요소를 나타내는 타입 별칭을 만드는 것이다.

## 구성 옵션

타입스크립트는 어떤 것이든 구성 가능하며 모든 일반적인 자바스크립트 사용 패턴에 맞출 수 있다.  
레거시 브라우저에서부터 가장 현대적인 서버 환경까지 다양한 프로젝트에서 작동 가능하다.

### tsc 옵션

tsc 명령은 타입스크립트의 대부분 옵션을 -- 플래그로 사용할 수 있다.  
tsc --help를 실행해 일반적으로 사용하는 CLI 플래그 목록을 가져올 수 있다.

#### _pretty 모드_

tsc CLI는 색상과 간격의 스타일을 지정해 가독성을 높이는 pretty 모드를 지원한다.  
출력 터미널이 여러 색상 텍스트를 지원한다는 것을 감지하면 기본적으로 pretty 모드로 설정된다.  
더 간결하고 색상이 없는 형식을 사용하고 싶다면 --pretty false를 실행하면 된다.

#### _watch 모드_

watch 모드를 사용하면 종료하는 대신 타입스크립트를 무기한 실행 상태로 유지하고 모든 오류의 실시간 목록을 가져와서 터미널을 지속적으로 업데이트한다.  
watch 모드는 여러 파일에 걸쳐서 리팩터링 같은 대규모 변경 작업을 할 때 유용하다.

### TSConfig 파일

tsconfig.json의 존재는 해당 디렉터리가 타입스크립트 프로젝트의 루트임을 나타낸다.  
디렉터리에서 tsc를 실행하면 해당 tsconfig.json 파일의 모든 구성 옵션을 읽는다.  
tsc 명령에 tsconfig.json 파일이 있는 디렉터리 경로 또는 tsc가 tsconfig.json 대신 사용할 파일 경로를 -p 또는 --project 플래그에 전달한다.

#### _tsc --init_

tsc 명령줄에는 tsconfig.json 파일을 생성하기 위한 --init 명령이 포함되어 있다.  
생성된 TSConfig 파일에는 구성 문서에 대한 링크와 사용을 간략하게 설명하는 한 줄 주석과 함께 허용되는 대부분의 타입스크립트 구성 옵션에 대한 링크도 포함된다.

#### _CLI vs 구성_

tsc --init에 따라 생성된 TSConfig 파일을 살펴보면 해당 파일의 구성 옵션이 "compilerOptions" 객체 내에 있다.  
CLI와 TSConfig 파일에서 사용 가능한 대부분의 옵션은 다음 두 가지 범주 중 하나로 분류된다.

- 컴파일러: 포함된 각 파일이 타입스크립트에 따라 컴파일되거나 타입을 확인하는 방법
- 파일: 타입스크립트가 실행될 파일과 실행되지 않은 파일

### 파일 포함

기본적으로 tsc는 현재 디렉터리와 하위 디렉터리에 있는 숨겨지지 않은 모든 .ts 파일에서 실행되고, 숨겨진 디렉터리와 node_modules 디렉터리는 무시한다.

#### _include_

파일을 포함하는 가장 흔한 방법으로 tsconfig.json의 최상위 "include" 속성을 사용한다.  
include 속성에 타입스크립트 컴파일에 포함할 디렉터리와 파일을 설명하는 문자열 배열을 명시한다.  
포함할 파일을 더 세밀하게 제어하기 위해 include 문자열에 글로브 와일드카드가 허용된다.

- \*: 0개 이상의 문자와 일치한다.(디렉터리 구분자 제외)
- ?: 하나의 문자와 일치한다.(디렉터리 구분자 제외)
- \*\*/: 모든 레벨에 중첩된 모든 디렉터리와 일치한다.

#### _exclude_

타입스크립트는 TSConfig 파일의 최상위 "exclude" 속성에 경로를 지정하고 include에서 경로를 생략한다.  
include처럼 타입스크립트 컴파일에서 제외할 디렉터리와 파일을 설명하는 문자열 배열이 허용된다.  
기본적으로 exclude에는 컴파일된 외부 라이브러리 파일에 대해 타입스크립트 컴파일러가 실행되지 않도록 ["node_modules", "bower_components", "jspm_packages"]가 포함된다.  
exclude는 include의 시작 목록에서 파일을 제거하는 작업만 수행한다.

### 대체 확장자

타입스크립트는 기본적으로 확장자가 .ts인 모든 파일을 읽을 수 있다.  
그러나 일부 프로젝트는 JSON 모듈 또는 JSX 구문처럼 확장자가 다른 파일을 읽을 수 있어야 한다.

#### _JSX 구문_

파일에서 JSX 구문을 사용하기 위해서는 다음 두 가지를 수행해야 한다.

- 구성 옵션에서 "jsx" 컴파일러 옵션을 활성화한다.
- .tsx 확장자로 파일의 이름을 지정한다.

타입스크립트가 .tsx 파일에 대한 자바스크립트 코드를 내보내는 방법은 "jsx" 컴파일러 옵션에 사용되는 값으로 결정된다.  
타입스크립트의 내장된 트랜스파일러를 직접적으로 사용하지 않는 경우에는 "jsx"에 대해 허용된 값을 사용할 수 있다.  
Next.js와 같은 최신 프레임워크로 구축된 대부분의 웹 앱은 리액트 구성 및 컴파일 구문을 처리한다.

#### _.tsx 파일의 제네릭 화살표 함수_

.tsx 파일에서 화살표 함수에 대한 타입 인수 \<T\>를 작성하려고 하면 T 요소의 시작 태그에 대한 종료 태그가 없기 때문에 구문 오류가 발생한다.  
이러한 구문 모호성을 해결하기 위해 타입 인수에 = unknown 제약 조건을 추가할 수 있다.

```typescript
const identity = <T = unknown>(input: T) => input;
```

#### _resolveJsonModule_

타입스크립트는 resolveJsonModule 컴파일러 옵션을 true로 설정하면 .json 파일을 읽을 수 있다.  
이렇게 하면 .json 파일을 마치 객체를 내보내는 .ts 파일인 것처럼 가져오고 해당 객체의 타입을 const 변수인 것처럼 유추한다.  
객체가 포함된 JSON 파일이라면 구조 분해 가져오기를 사용한다.  
esModuleInterop 컴파일러 옵션이 활성화된 경우에도 기본 가져오기를 사용할 수 있다.  
array 또는 number 같은 다른 리터럴 타입을 포함한 JSON 파일이라면 import 구문으로 \*을 사용한다.

### 자바스크립트로 내보내기

바벨 같은 전용 컴파일러 도구의 등장으로 일부 프로젝트에서 타입스크립트의 역할이 타입 검사만으로 축소되었지만, 여전히 타입스크립트에 의존하고 있는 프로젝트도 존재한다.

#### _outDir_

기본적으로 타입스크립트는 출력 파일을 해당 소스 파일과 동일한 위치에 생성한다.  
타입스크립트의 outDir 컴파일러 옵션을 사용하면 출력 파일의 루트 디렉터리를 다르게 지정할 수 있다.  
출력 파일은 입력 파일과 동일한 디렉터리 구조를 유지한다.  
모든 입력 소스 파일을 단일 디렉터리에 배치하는 프로젝트는 해당 디렉터리를 루트로 처리한다.

#### _target_

타입스크립트는 자바스크립트 코드 구문을 지원하기 위해 어느 버전까지 변환해야 하는지를 지정하는 target 컴파일러 옵션을 제공한다.  
target을 지정하지 않으면 이전 버전과의 호환성을 위해 기본적으로 "es3"이 지정된다.  
오래된 환경에서 최신 자바스크립트 기능을 지원하려면 더 많은 자바스크립트 코드를 생성해야 하므로, 파일 크기가 조금 더 커지고 런타임 성능이 조금 저하된다.

#### _내보내기 선언_

declaration 컴파일러 옵션을 사용해 소스 파일에서 .d.ts 출력 파일을 내보낸다.  
.d.ts 출력 파일은 outDir 옵션에 따라 .js 파일과 동일한 출력 규칙에 따라 내보내진다.  
emitDeclarationOnly 컴파일러 옵션을 사용해 .js와 .jsx 파일 없이 선언 파일만 내보내도록 지시할 수 있다.

#### _소스 맵_

소스 맵은 출력 파일의 내용이 원본 소스 파일과 어떻게 일치하는지에 대한 설명이다.  
소스 맵은 출력 파일을 탐색할 때 디버거 같은 개발자 도구에서 원본 소스 코드를 표시하도록 설정한다.  
브라우저 개발자 도구와 IDE에서 디버깅하는 동안 원본 소스 파일 내용을 볼 수 있도록 하는 시각적인 디버거에 소스 맵이 유용하다.  
타입스크립트의 sourceMap 컴파일러 옵션을 사용하면 .js 또는 .jsx 출력 파일과 함께 .js.map 또는 .jsx.map 소스 맵을 출력할 수 있다.  
declarationMap 컴파일러 옵션은 원본 소스 파일에 해당하는 각 .d.ts에 대한 .d.ts.map 소스 맵을 생성하도록 지시한다.

#### _noEmit_

다른 도구를 이용해 소스 파일을 컴파일하고, 자바스크립트를 출력하는 프로젝트에서 타입스크립트는 파일 생성을 모두 건너뛰도록 지시할 수 있다.  
noEmit 컴파일러 옵션을 활성화하면 타입스크립트가 온전히 타입 검사기로만 작동한다.
