# 러닝 타입스크립트

## 목차

- [타입스크립트란](#타입스크립트란)
- [타입 시스템](#타입-시스템)
- [유니언과 리터럴](#유니언과-리터럴)
- [객체](#객체)

## 타입스크립트란

타입스크립트는 종종 '자바스크립트의 상위 집합<sup>superset</sup>' 혹은 '타입이 있는 자바스크립트'로 설명되곤 한다.  
타입스크립트는 네 가지로 설명된다.

- 프로그래밍 언어: 자바스크립트의 모든 구문과, 타입을 정의하고 사용하기 위한 새로운 타입스크립트 고유 구문이 포함된 언어
- 타입 검사기: 자바스크립트 및 타입스크립트로 작성된 일련의 파일에서 생성된 모든 구성 요소를 이해하고, 잘못 구성된 부분을 알려주는 프로그램
- 컴파일러: 타입 검사기를 실행하고 문제를 보고한 후 이에 대응되는 자바스크립트 코드를 생성하는 프로그램
- 언어 서비스: 타입 검사기를 사용해 VS Code와 같은 편집기에 개발자에게 유용한 유틸리티 제공법을 알려주는 프로그램

## 타입 시스템

### 타입의 종류

'타입'은 자바스크립트에서 다루는 값의 **형태**에 대한 설명이다. 여기서 '형태'란 값에 존재하는 속성과 메서드 그리고 내장되어 있는 typeof 연산자가 설명하는 것을 의미한다.  
타입스크립트의 가장 기본적인 타입은 자바스크립트의 일곱 가지 기본 원시 타입<sup>primitive type</sup>과 동일하다.  
일곱 가지 원시 타입은 다음과 같다.

- null
- undefined
- boolean
- string
- number
- bigint
- symbol

### 타입 시스템

타입 시스템<sup>type system</sup>은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다.  
기본적으로 타입스크립트의 타입 시스템은 다음과 같이 작동한다.

1. 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인한다.
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다.

### 오류 종류

타입스크립트를 작성하는 동안 가장 자주 접하게 되는 오류로 구문 오류와 타입 오류가 있다.

#### 구문 오류

구문 오류는 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생한다. 이는 타입스크립트가 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단한다.

#### 타입 오류

타입 오류는 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지할 때 발생한다. 오류가 발생했다고 해서 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지는 않습니다.

### 할당 가능성

타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다. 나중에 해당 변수에 새로운 값이 할당되면, 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인하고 만약 다른 타입의 값이 할당되면 타입 오류가 발생한다.  
타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당 가능성**<sup>assignability</sup>이라고 한다. 즉, 전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인한다.

### 타입 애너테이션

타입스크립트는 초깃값이 없는 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않는다. 그리고 기본적으로 변수를 암묵적인 any 타입으로 간주한다.  
초기 타입을 유추할 수 없는 변수는 **진화하는 any**라고 부른다. any 타입인 변수에 새로운 값이 할당될 때마다 변수의 타입이 변한다.  
타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입 애너테이션**<sup>type annotation</sup>을 제공한다.  
변수에 타입 애너테이션으로 정의한 타입 외의 값을 할당하면 타입 오류가 발생한다.

```typescript
let name: string;
name = "seeyoujeong";
```

#### 불필요한 타입 애너테이션

타입스크립트가 타입을 유추할 수 있는 변수에 타입 애너테이션을 추가하면 중복이다.  
초깃값이 있는 변수에 타입 애너테이션을 추가하면 타입스크립트는 변수에 할당된 값의 타입이 일치하는지 확인한다.  
많은 개발자는 아무것도 변하지 않는 변수에 타입 애너테이션을 추가하지 않기를 선호한다.  
코드를 명확하게 문서화하거나 실수를 방지하기 위해 명시적으로 타입 애너테이션을 포함하는 것이 유용한 경우도 있다.

### 타입 형태

타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있다. 그리고 객체의 형태에 대한 이해를 바탕으로 할당 가능성뿐만 아니라 객체 사용과 관련된 문제도 알려준다.

#### 모듈

타입스크립트는 최신 모듈(export 또는 import가 있는 파일) 파일을 기존 파일과 함께 실행할 수 있다.  
파일이 스크립트(모듈이 아닌 모든 파일)면 해당 파일을 전역 스코프로 간주한다. 따라서 동일한 이름의 변수가 동일한 파일에 선언된 것처럼 서로 충돌한다.  
강제로 모듈이 되도록 만들고 싶으면 파일의 아무 곳에나 export {};를 추가하면 된다.  
타입스크립트는 일반적으로 CommonJS 스타일의 require 함수에서 반환된 값을 any 타입으로 인식한다.

## 유니언과 리터럴

타입스크립트는 코드 정보에 입각한 추론을 수행하는 유니언<sup>union</sup>과 내로잉<sup>narrowing</sup>이라는 두 가지 개념이 있다.

### 유니언 타입

유니언 타입은 값이 정확히 어떤 타입인지 모르지만 두 개 이상의 옵션 중 하나라는 것을 알고 있는 경우에 코드를 처리하는 개념이다.  
타입스크립트는 가능한 값 또는 구성 요소 사이에 |(수직선) 연산자를 사용해 유니언 타입을 나타낸다.

#### 유니언 타입 선언

변수의 초깃값이 있더라도 변수에 대한 명시적 타입 애너테이션을 제공하는 것이 유용할 때 유니언 타입을 사용한다.  
유니언 타입 선언은 타입 애너테이션으로 타입을 정의하는 모든 곳에서 사용할 수 있다.

#### 유니언 속성

값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있다.  
유니언 타입으로 정의된 여러 타입 중 하나의 타입으로 된 값의 속성을 사용하려면 코드에서 값이 보다 구체적인 타입<sup>specific type</sup> 중 하나라는 것을 타입스크립트에 알려야 한다.

### 내로잉

내로잉은 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것이다.  
타입을 좁히는 데 사용할 수 있는 논리적 검사를 타입 가드<sup>type guard</sup>라고 한다.

#### 값 할당을 통한 내로잉

변수에 값을 직접 할당하면 타입스크립트는 변수의 타입을 할당된 값의 타입으로 좁힌다.  
변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 값 할당 내로잉이 작동한다.

#### 조건 검사를 통한 내로잉

일반적으로 타입스크립트에서는 변수가 알려진 값과 같은지 확인하는 if 문을 통해 변수의 값을 좁히는 방법을 사용한다.  
타입스크립트는 if 문 내에서 변수가 알려진 값과 동일한 타입인지 확인한다.

#### typeof 검사를 통한 내로잉

타입스크립트는 직접 값을 확인해 타입을 좁히기도 하지만, typeof 연산자를 사용할 수도 있다.

### 리터럴 타입

리터럴 타입<sup>literal type</sup>은 좀 더 구체적인 버전의 원시 타입이다.  
원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입이 리터럴 타입이다.  
원시 타입은 해당 타입의 가능한 모든 리터럴 값의 집합이다.  
리터럴 타입은 그 값이 해당하는 원시 타입에 할당할 수 있다.

### 엄격한 null 검사

엄격한 null 검사는 다른 타입이 필요한 위치에서 null 값을 사용하지 못하도록 검사하는 것이다.  
엄격한 null 검사를 활성화해야만 코드가 null 또는 undefined 값으로 인한 오류로부터 안전한지 여부를 쉽게 파악할 수 있다.

#### 참 검사를 통한 내로잉

타입스크립트는 잠재적인 값 중 truthy로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있다.  
논리 연산자인 &&와 ?는 참 여부를 검사하는 일을 잘 수행한다. 하지만 참 여부 확인 외에 다른 기능(빈 문자열인지 undefined인지)은 제공하지 않는다.

#### 초깃값이 없는 변수

타입스크립트는 값이 할당될 때까지 변수가 undefined임을 이해할 만큼 충분히 영리하다.  
값이 할당되기 전에 속성 중 하나에 접근하려는 것처럼 해당 변수를 사용하려고 시도하면 '할당 전'이라는 오류 메시지가 나타난다.  
변수 타입에 undefined가 포함되어 있는 경우에는 오류가 보고되지 않는다.

### 타입 별칭

타입 별칭<sup>type alias</sup>은 **type 새로운 이름 = 타입** 형태를 갖는다. 편의상 타입 별칭은 파스칼 케이스로 이름을 지정한다.  
타입 별칭은 타입 시스템의 '복사해서 붙여넣기'처럼 작동한다.  
타입 별칭은 타입 애너테이션처럼 자바스크립트로 컴파일되지 않는다.  
타입 별칭은 다른 타입 별칭을 참조할 수 있고 사용 순서대로 선언할 필요는 없다.

## 객체

### 객체 타입

{...} 구문을 사용해서 객체 리터럴을 생성하면, 타입스크립트는 해당 속성을 기반으로 새로운 객체 타입 또는 타입 형태를 고려한다. 해당 객체 타입은 객체의 값과 동일한 속성명과 원시 타입을 갖는다.  
존재하지 않는 속성 이름으로 접근하려고 하면 해당 이름이 존재하지 않는다는 타입 오류가 발생한다.

### 객체 타입 선언

객체 타입은 객체 리터럴과 유사하게 보이지만 필드 값 대신 타입을 사용해 설명한다.  
타입스크립트가 타입 할당 가능성에 대한 오류 메시지에 표시하는 것과 동일한 구문이다.

### 별칭 객체 타입

객체 타입에 타입 별칭을 할당해 사용하는 방법이 일반적이다.

```typescript
type User = {
  born: number;
  name: string;
};
```

### 구조적 타이핑

타입스크립트의 타입 시스템은 구조적으로 타입화<sup>structurally typed</sup>되어 있다. 이 말은 매개변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야 한다는 의미이다.  
구조적 타이핑은 덕 타이핑<sup>duck typing</sup>과는 다르다. 구조적 타이핑은 정적 시스템이 타입을 검사하는 경우이며, 덕 타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것을 말한다.

#### 사용 검사

객체 타입으로 애너테이션된 위치에 값을 제공할 때 타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인한다.  
할당하는 값에는 객체 타입의 필수 속성이 있어야 하고 없으면 타입스크립트는 타입 오류를 발생시킨다.
필수 속성 이름은 일치하고 타입이 일치하지 않으면 타입 오류를 발생시킨다.

#### 초과 속성 검사

변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있다면 타입스크립트에서 타입 오류가 발생한다.  
초과 속성 검사는 객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어난다. 기존 객체 리터럴을 제공하면 초과 속성 검사를 우회한다.  
타입스크립트에서 초과 속성을 금지하면 코드를 깨끗하게 유지할 수 있고, 예상한 대로 작동하도록 만들 수 있다.

#### 선택적 속성

타입의 속성 애너테이션에서 : 앞에 ?를 추가하면 선택적 속성임을 나타낼 수 있다.  
선택적 속성과 undefined를 포함한 유니언 타입의 속성 사이에는 차이가 있다. ?를 사용해 선택적으로 선언된 속성은 존재하지 않아도 되지만 필수로 선언된 속성과 | undefined는 그 값이 undefined일지라도 반드시 존재해야 한다.

### 객체 타입 유니언

타입스크립트 코드에서 속성이 조금 다른, 하나 이상의 서로 다른 객체 타입이 될 수 있는 타입을 설명할 수 있어야 한다.  
속성값을 기반으로 해당 객체 타입 간에 타입을 좁혀야 할 수도 있다.

#### 유추된 객체 타입 유니언

변수에 여러 객체 타입 중 하나가 될 수 있는 초깃값이 주어지면 타입스크립트는 해당 타입을 객체 타입 유니언으로 유추한다.  
객체 타입에 정의된 각각의 가능한 속성은 비록 초깃값이 없는 선택적(?) 타입이지만 각 객체 타입의 구성 요소로 주어진다.

#### 명시된 객체 타입 유니언

객체 타입의 조합을 명시하면 객체 타입을 더 명확히 정의할 수 있다.  
값의 타입이 객체 타입으로 구성된 유니언이라면 타입스크립트의 타입 시스템은 이런 모든 유니언 타입에 존재하는 속성에 대한 접근만 허용한다.

#### 객체 타입 내로잉

코드에서 객체의 형태를 확인하고 타입 내로잉이 객체 적용된다.  
존재하지 않는 객체의 속성에 접근하려고 시도하면 타입 가드처럼 작동하는 방식으로 사용되더라도 타입 오류로 간주된다.

#### 판별된 유니언

객체의 속성이 객체의 형태를 나타내도록 하는 타입 형태를 판별된 유니언<sup>discriminated union</sup>이라 부르고, 객체의 타입을 가리키는 속성이 판별값이다. 타입스크립트는 코드에서 판별 속성을 사용해 타입 내로잉을 수행한다.

```typescript
type PoemWithPages = {
  name: string;
  pages: number;
  type: "pages";
};

type PoemWithRhymes = {
  name: string;
  rhymes: boolean;
  type: "rhymes";
};
```

### 교차 타입

타입스크립트에서 & 교차 타입<sup>intersection type</sup>을 사용해 여러 타입을 동시에 나타낸다.  
교차 타입은 일반적으로 여러 기존 객체 타입을 별칭 객체 타입으로 결합해 새로운 타입을 생성한다.  
교차 타입을 사용할 때는 가능한 한 코드를 간결하게 유지해야 한다.  
교차 타입은 잘못 사용하기 쉽고 불가능한 타입(never)을 생성한다. 원시 타입의 값은 동시에 여러 타입이 될 수 없기 때문에 교차 타입의 구성 요소로 함께 결합할 수 없다.
